-- ============================================================
-- ============================================================
-- 
-- 
--                    ФАЙЛОВЫЙ LUA-МОДУЛЬ,
-- 
--               написанный специально для игры
--             Ex Machina / Hard Truck Apocalypse
--
--                     XMLParser v1.0.1
-- 
-- 
-- ====================== Автор E Jet =========================
-- ============================================================
-- 
--     Note: Please translate this text, if it nessesary.
-- 
-- 
-- ======================= ЧТО ЭТО ============================
-- 
-- 
--      Универсальный lua-модуль, который может использоваться
-- для ЧТЕНИЯ и ЗАПИСИ .xml файлов через скрипты любой 
-- модификации внутри игры.
--      Вы сможете прочитать xml-дерево, получить значения его 
-- объектов и использовать их в игре. Кроме того, здесь имеется,
-- не весть какой, но конструктор, который позволит вам создавать 
-- файлы, а затем записывать/читать деревья и объекты внутри них.
-- 
--      Почему это "модуль", а не любой другой файл с lua-скриптами?
-- Хотя он таким и является...
--      Потому что этот файл - таблица функций XMLParser 
-- (далее класс), который имеет свои собственные методы и функции,
-- что очень похоже на серьезную тему. Наверное. Типа. Я хз...
--
------------------------- Дисклеймер -----------------------
--
--      АВТОР ЭТОГО ТВОРЕНИЯ ДУМАЕТ, ЧТО ЗНАЕТ, КАК ПРАВИЛЬНО
-- НАЗЫВАТЬ И ИСПОЛЬЗОВАТЬ ВЕЩИ В ПРОГРАММИРОВАНИИ, ПОЭТОМУ 
-- ПРОСЬБА ДЛЯ ПРОГРАММИСТОВ ЗДОРОВОГО ЧЕЛОВЕКА - ПОНЯТЬ И 
-- ПРОСТИТЬ, ЕСЛИ ЗДЕСЬ ЧТО-ТО(ВСЕ) НЕ ТАК. 
--      АВТОР ПОНИМАЕТ И ПРИНИМАЕТ, ЧТО ВЕСЬ КОД НИЖЕ И ЭТОТ
-- ТЕКСТ НАПИСАН ПЛОХО, НЕПОНЯТНО И ГРОМОЗДКО, ЧТО ДАЖЕ В ЭТОМ
-- ЗАНЯТИИ НЕТ НИ МАЛЕЙШЕГО СМЫСЛА - КАК И СМЫСЛА В ЭТОМ КАПСОМ 
-- НАПИСАННОМ ДИСКЛЕЙМЕРЕ.
--
--      LUA-МОДУЛЬ РАСПРОСТРАНЯЕТСЯ СВОБОДНО "КАК ЕСТЬ" И 
-- ИСПОЛЬЗУЕТСЯ ИГРОЙ EX MACHINA / HARD TRUCK APOCALYPSE ДЛЯ  
-- ЧТЕНИЯ, ИЗМЕНЕНИЯ, СОЗДАНИЯ, А ТАКЖЕ УДАЛЕНИЯ(!) ФАЙЛОВ НА  
-- ВАШЕМ КОМПЬЮТЕРЕ И МОЖЕТ БЫТЬ ИЗМЕНЕН ЛЮБЫМ ДРУГИМ 
-- ПОЛЬЗОВАТЕЛЕМ (МОДДЕРОМ) ВНУТРИ СВОИХ МОДИФИКАЦИЙ И ПРОЧИХ 
-- РЕСУРСАХ.
--      АВТОР НЕ НЕСЕТ ОТВЕТСТВЕННОСТИ ЗА КАКИЕ-ЛИБО ПОСЛЕДСТВИЯ, 
-- ПОВЛЕКШИХ ЗА СОБОЙ УЩЕРБ ВО ВРЕМЯ ИСПОЛЬЗОВАНИЯ ЭТОГО, А
-- ТАКЖЕ ЛЮБОЙ ДРУГОЙ, В Т.Ч. ИЗМЕНЕННОЙ ВЕРСИИ LUA-МОДУЛЯ ИЛИ
-- ЧАСТЕЙ КОДА, ПОЗАИМСТВОВАННЫХ (ПЕРЕПИСАННЫХ) ИЗ ЭТОГО ФАЙЛА.
-- 
---------------------------------------------------------------
--
-- ================= КАК ЭТО ИСПОЛЬЗОВАТЬ =====================
-- 
-- 
--      Для полноценного lua-модуля этой поделке еще далеко, 
-- поэтому ее не нужно устанавливать как lua-библиотеку в системе.
-- 
--      В игру этот lua-модуль загружается двумя способами: через 
-- [require()] или [dofile()]. Это внутренние lua-команды игры. 
-- Наш знакомый [EXECUTE_SCRIPT] не подойдет, так как он не возвращает 
-- объект модуля.
--      Чем отличается [require()] от [dofile()]? 
--      - [require()] загружает файл в игру при первом выполнении
-- и держит в памяти игры до перезапуска. Эта команда используется 
-- для подгрузки модулей здорового человека, которые устанавливаются 
-- в систему (но необязательно);
--      - [dofile()] загружает в память игры файл столько раз, 
-- сколько был вызван. Очищается весь внутренний кеш lua-модуля и
-- принимаются настройки по умолчанию. Рекомендуется для отладки и
-- прочего дебага.
--      Рекомендую прописывать команду в начало файла server.lua
-- игры, поскольку могут использоваться в модуле команды, которые 
-- грузятся в игру чуть раньше сервера ("могут"? автор альцгеймер!).
--
--      В качестве аргумента функции указывается локальный путь до 
-- файла модуля.
--      Возвращаемая таблица помещается в глобальную переменную, 
-- которая будет использована как объект, на который будут 
-- применяться методы (функции) этого модуля через двоеточие. 
--
-- Чтобы было понятнее, вспомним как мы обращаемся к машине игрока:
-- 
-- lua
-- [[
--      local Plv = GetPlayerVehicle()
--      if Plv then
--          Plv:SetSkin(1)  --> метод на объект
--      end
-- ]]
--
-- Или к обжект контейнеру:
--
-- lua
-- [[
--      local Gde = CVector(1,2,3)
--      local Gde.y = g_ObjCont:GetHeight(Gde.x, Gde.z)  --> метод на объект
-- ]]
-- 
--      После загрузки модуля в игру следует инициализировать
-- его работу через метод [init()]. Это необходимо, чтобы указать
-- парсеру файл для "анализа" и имя xml-корня или другого дерева.
-- Функция может быть вызвана вновь в любой момент.
--
---------------------- МЕТОД init() ---------------------------
-- lua
-- [[
--      XMLParser:init(path_to_file, root_tag_in_file, default_file_content, bLOG)
-- ]]
-- 
--  path_to_file            - путь к xml-файлу [string]
--  root_tag_in_file        - имя главного xml-корня (дерева) в файле [string]
--  default_file_content    - (необязательно) содержимое xml-файла по умолчанию (при создании файла), указывается как пример example_content ниже [string]
--  bLOG                    - (необязательно) разрешает/запрещает принтить (выводить) всю дебаг информацию в лог и консоль игры [bool]
--
-- lua
-- [[
--      local example_content = '<?xml version="1.0" encoding="windows-1251" standalone="yes" ?>\n<Root>\n<!-- здесь ваши данные -->\n</Root>'
-- ]]
-- 
-----------------------------------------------------------------
--
----------------- \/ Пример кода загрузки \/ --------------------
--
-- lua
-- [[
--     g_XMLParser = require("data\\gamedata\\lua_lib\\xmlparser.lua")
--     if not g_XMLParser then
--         LOG("[E] Could not find global xmlparser.lua...")
--     else
--         g_XMLParser:init("data\\gamedata\\ModStats.xml", "ModStats", nil, false)
--     end
-- ]]
--
---------------------------------------------------------------
--
-- ================= ТЕХНИКА БЕЗОПАСНОСТИ =====================
--
--
--      НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ перед работой ознакомиться 
-- с памятками ниже [Что такое "дерево"], [Что такое "объект"] и
-- [Что такое "поле текста"] в понимании этого lua-модуля.
--      В противном случае гарантия правильной работы говно- 
-- парсера аннулируется.
--
--      КАТЕГОРИЧЕСКИ ЗАПРЕЩАЕТСЯ использовать в именах, 
-- значениях и прочих ключах следующие символы: </>"
--      А также рекомендуется отказаться от прочих управляющих
-- и неэкранированных уникальных символов (я поместил их в
-- "клетки" из [""] через запятую): ["\\"],["\""],["'"],["?"],
-- ["["],["]"],["("],[")"],["."],["^"],["$"],["*"],["+"],["-"],
-- ["%"].
--      В противном случае гарантия правильной работы говно- 
-- парсера аннулируется.
--
--      КАТЕГОРИЧЕСКИ ЗАПРЕЩАЕТСЯ использовать этот lua-модуль 
-- на файлах, размещаемых вне игры и модификации! Нет, нельзя!
--      Только Ex Machina и только модификации к ней! 
--
--      Запрещается создавать полностью одинаковые деревья с 
-- идентичными тегами и именами, даже внутри разных деревьев.
--      В противном случае гарантия правильной работы говно- 
-- парсера аннулируется.
--
--      Следует помнить, что xml-разметка в файле должна быть
-- "чистой" - соблюдается табуляция у объектов (отступы), 
-- отсутствуют ненужные пробелы и управляющие символы. Про 
-- правильный xml-синтаксис я напомню вам чисто так, невзначай.
--      В противном случае гарантия правильной работы говно- 
-- парсера аннулируется.
--
--      Не рекомендуется использовать этот lua-модуль на важных
-- игровых xml-файлах, так как в ходе внезапной неправильной
-- работы парсера сломаете игру. Делайте такие действия с
-- осторожностью, либо проведите тестирование своего скрипта на
-- подопытном файле.
--
--      Не рекомендуется использовать этот lua-модуль на сложных
-- xml-структурах.    
--
--      ЗАПРЕЩАЕТСЯ использовать этот lua-модуль в своих модах
-- без указания авторства.
--      А то натравлю порчу и наколдую недельный понос >:(
--      Шутка :*
--
---------------------------------------------------------------
--
-- =================== ФУНКЦИИ И МЕТОДЫ =======================
--
--
--      Здесь собраны все публичнные функции этого модуля. У 
-- каждой функции имеется детальное описание, что она делает и
-- что в ней указывать. 
--      Прочтите описание парсера полностью, чтобы лучше понимать, 
-- что это за парацетамол. Пользуйтесь на здоровье!
--
--      Раскомментируйте дерево Class XMLParser, чтобы 
-- программа, через которую вы это читаете, смогла подсветить 
-- синтаксис для удобной навигации по функциям. Не забудьте 
-- закомментировать обратно! Или скопируйте его куда-то себе...
--
--      Обратите внимание, что дочерний класс должен вызывать 
-- главный метод своего родительского класса вплоть до XMLParser.
--
--      Учтите, что функции для редактирования объектов и деревьев 
-- РАБОТАТЬ НЕ БУДУТ, если применяются на подобъекты захватываемого 
-- дерева.
--      Сначала вам следует сделать дерево-подобъект активным.
--
--      По умолчанию в некоторых командах вместо аргумента [self]
-- указывайте [nil] при вызове.
--
---------------------------------------------------------------
--
-- c
-- [[
--     Class XMLParser
--     {
--         /* Основные функции */
--         [M] bool IsFileExists( const char* path_to_file )    /* Проверяет, существует ли файл по этому пути */
--         [M] bool IsFileOpen( file descryptor )               /* Проверяет, открыт ли файл в памяти по этому дескриптору */
--         [M] bool&descryptor init( const char* path_to_file, const CStr& root_tag_in_file, const CStr& default_file_content, bool LOG )  /* Инициализирует "точку входа" парсера в файле, перезатирает ранее установленные параметры парсера. bool LOG принтит дебаг информацию, если нужно отследить, что не нравится парсеру или где он ломается (Внимание! Принтит ОЧЕНЬ много мусора в лог игры и вызывает НАИСИЛЬНЕЙШУЮ утечку памяти) */
--         [M] bool save()      /* Сохраняет в файл все изменения, произведенные парсером */
--         [M] bool createFile( const char* path, const CStr& default_file_content )     /* Создает (ПЕРЕЗАТИРАЕТ) файл и записывает в него базовый контент, указанный в default_file_content или в init(). По умолчанию это "data\\gamedata\\file_name.xml" */
--         [M] bool removeFile()       /* Удаляет файл, указанный в init(). По умолчанию это "data\\gamedata\\file_name.xml" */
--         [M] void AutoUpdateTree( bool Value )       /* Включает/отключает автоматическое обновление дерева TREE при каждом вызове дочерних методов TREE */
--         
--         /* Универсальные функции */
--         [M] string QuickGet( const char* path_to_file, const char* AttrName )                  /* Возвращает значение атрибута из файла. Работает быстро, возвращает первое совпадение! Не использует кэш и переменные парсера, игнорирует пробелы и табуляцию */
--         [M] bool QuickSet( const char* path_to_file, const char* AttrName, const CStr& AttrValue )  /* Назначает значение атрибута в файле. Работает быстро, редактирует первое совпадение! Не использует кэш и переменные парсера, игнорирует пробелы и табуляцию */
--         [M] string QuickParseLine( const char* path_to_file, const char* LinePattern )         /* Возвращает захваченный паттерн строки из файла. Ищет построчно до первого совпадения, работает с регулярными выражениями */
--         [M] bool openQueue( const char* path_to_file )           /* Открывает очередь для команд ниже (и не только), открывает файл и держит его в памяти. Пока открыта очередь, команды парсера будут применяться к файлу по этому пути */
--         [M] table GetItemFromFile( string FindExample, const char* ItemTagName, const char* ItemRepositoryName )       /* Возвращает XMLParser-объект из выбранного xml файла, используется без init(). Не нагружает игру как простое чтение XMLParser через init() у большого файла. Очень полезно для чтения огромных файлов (таких как dialogsglobal.xml или currentmap.xml) а также более "шелкового касания" объекта, нежели как это делает автоматически XMLParser, однако необходимо уже вручную разбирать возвращаемую таблицу. Аргументы: FindExample - образец строки для первичного поиска. Указывается один из атрибутов объекта, например имя: 'name="object_name"'; ItemTagName - имя открывающего тега этого объекта; ItemRepositoryName - имя открывающего/закрывающего тега дерева, где этот объект находится. */
--         [M] bool SetItemValueInFile( string FindExample, const char* ItemTagName, const char* ItemRepositoryName, const char* AttributeName, const char* Pattern, const CStr& AttributeValue )    /* Изменяет параметр объекта в выбранном xml файле, используется без init(). Не нагружает игру как простое чтение XMLParser через init() у большого файла. Очень полезно для чтения огромных файлов (таких как dialogsglobal.xml или currentmap.xml) а также более "шелкового касания" объекта, нежели как это делает автоматически XMLParser. Аргументы: FindExample - образец строки для первичного поиска. Указывается один из атрибутов объекта, например имя: 'name="object_name"'; ItemTagName - имя открывающего тега этого объекта; ItemRepositoryName - имя открывающего/закрывающего тега дерева, где этот объект находится; AttributeName - имя атрибута; Pattern - что нужно найти и заменить. Если nil, будет весь текст атрибута; AttributeValue - на что нужно заменить. Если nil, будет весь текст атрибута. */
--         [M] bool RemoveItemFromFile( string FindExample, const char* ItemTagName, const char* ItemRepositoryName )     /* Удаляет найденный XMLParser-объект из выбранного xml файла, используется без init(). Не нагружает игру как простое чтение XMLParser через init() у большого файла. Очень полезно для чтения огромных файлов (таких как dialogsglobal.xml или currentmap.xml) а также более "шелкового касания" объекта, нежели как это делает автоматически XMLParser, однако необходимо уже вручную разбирать возвращаемую таблицу. Аргументы: FindExample - образец строки для первичного поиска. Указывается один из атрибутов объекта, например имя: 'name="object_name"'; ItemTagName - имя открывающего тега этого объекта; ItemRepositoryName - имя открывающего/закрывающего тега дерева, где этот объект находится. */
--         [M] bool closeQueue( table content, file descryptor )    /* Закрывает очередь для команд выше (и не только), закрывает файл и сохраняет изменения в нем. Не указывайте аргументы для работы с текущим открытым файлом */
--     
--         /* Сервисные функции. По возможности не используйте */
--         [M] void clearCache()       /* Сбрасывает глобальные переменные парсера в настройки по умолчанию. После этого необходимо снова инициализировать парсер через init() */
--         [M] table getCache()        /* Возвращает все глобальные переменные парсера. Индексы переменных можно посмотреть в логе игры, если включен bool LOG в init() */
--         [M] void ConvertPropertiesIn( const char* InputPATH, const char* OutputPATH )    /* Конвертирует значения объектов из файла (dynamicscene, world) в удобные варианты копирования для скриптов в файл OutputPATH, иначе в корень как func_ConvertPropertiesIn.xml. Примеры: rot="0.0004 0.9786 -0.2058 0.0021" --> rot="Quaternion(0.0004, 0.9786, -0.2058, 0.0021)"; Pos="326.145 436.152 2804.116" --> Pos="CVector(326.145, 436.152, 2804.116)" */ 
--         [M] AIParam ReadBinary( const char* path_to_file )       /* Читает бинарные файлы. Возвращает размер файла в байтах, килобайтах и мегабайтах. [.AsHex] - возвращает Hex-содержимое файла, [.AsASCII] - возвращает ASCII-содержимое файла */
--         [M] bool AddCommentNearItem( string comment, table itemParams )  /* Добавляет комментарий над элементом. Используйте [XMLParser:Tree( table treeParams ):init()] перед выполнением команды */
--         [M] string GetLineWithContent( int line, string Content )        /* Возвращает строку и ее номер из файла, ищет первое совпадение по Content, если указан (поддержка регулярных выражений). Используйте [XMLParser:Tree( table treeParams ):init()] перед выполнением команды */
--         [M] tuple RemoveLineWithContent( int line, string Content )      /* Удаляет строку в файле (Осторожно! Можно сломать разметку файла!). Возвращает истину, номер строки и само значение строки, в противном случае nil. Ищет первое совпадение по Content, если указан (поддержка регулярных выражений). Используйте [XMLParser:Tree( table treeParams ):init()] перед выполнением команды */
--         [M] bool addTree( table treeParams, table put_inParams, table includeKeysForSort )       /* Добавляет xml дерево в дерево table put_inParams, иначе в корень. Сортирует новые ключи параметров сверху вниз, если указаны. Сортируемые ключи сверху вниз по умолчанию: "id", "Id", "ObjectId", "Name", "name", "Amount", "Maximum", "Description" */
--         [M] bool addObject( table objectParams, table put_inParams, table includeKeysForSort)    /* Добавляет xml объект в дерево put_inParams, иначе в корень. Сортирует новые ключи параметров сверху вниз, если указаны. Сортируемые ключи сверху вниз по умолчанию: "id", "Id", "ObjectId", "Name", "name", "Value", "ListOfItems", "Chassis", "Cabin", "Cargo", "Skin", "ListOfGuns", "Name", "Status", "Item", "Description", "Difficulty", "Done" */
--         [M] bool removeTree( table treeParams )     /* Удаляет xml дерево */
--         [M] bool removeObject( table treeParams, table objectParams )     /* Удаляет xml объект в дереве */
--         [M] string Wrap( table objectParams )       /* Возвращает свернутый item */
--         [M] table Unwrap( table objectParams )      /* Возвращает развернутый item */
--         [M] tuple getTree( const table* treeParams, const char* put_in )    /* Возвращает все найденные параметры, items и все childs дерева, сложенного в put_in, иначе найдет первое вхождение или nil */
--         [M] table getItemFromLine( const table* content, const int* Line, const CStr& parentName, const char* parentTabs )       /* Возвращает найденный item из content, все его параметры и все вложенные дочерние item и их параметры, начиная с номера строки Line. Ищет закрывающий тег parentName вместе с parentTabs. Громоздкая и рекурсивная функция, дающая памяти игры утечь куда глаза глядят, если xml конструкция достаточно сложная */
--         [M] string getItemClass( const table* content, const int* curLine )     /* Проверяет item из content, под номером строки curLine и возвращает его класс: "tree", "object" */
--         [M] table GetTagAndCustomKeyFromItem( const table* itemParams )         /* Возвращает имя тега и пользовательский параметр item. Пользовательские ключи задаются в PARSER.KEYS */
--         [M] string GetItemCustomKey( const table* itemParams, const table* keys )    /* Возвращает ключ объекта и его значение. Берет table keys из PARSER.KEYS_SearchingGradient если nil. */
--     
--
--         /* Чтение и редактирование XML */
--         Class TREE
--         {
--             [M] TREE Tree( table treeParams ) : public XMLParser     /* Это прямое обращение к дереву TREE. Используйте [XMLParser:Tree( table treeParams ):init()] перед выполнением команд. Во время использования команд аргумент в Tree() не нужен */
--             {
--                 [M] bool init( table new_treeParams )      /* Обновляет содержимое TREE, захватывает новое дерево если указан new_treeParams */
--                 [M] bool IsObjectExists( table ObjectTagXorCustomKey, string CustomKeyValue )      /* Проверяет, существует ли такой объект в дереве: [{"TagName", "Name"}, "bibka"]. Пользовательские ключи задаются в PARSER.KEYS */
--                 [M] bool IsTreeExists( table TreeTagXorCustomKey, string CustomKeyValue )          /* Проверяет, существует ли такое дерево в дереве: [{"TagName", "Name"}, "bibka"]. Пользовательские ключи задаются в PARSER.KEYS */
--                 [M] bool CaptureInnerTree( table TreeTagXorCustomKey, string CustomKeyValue )      /* Помещает найденное дерево внутри дерева в TREE (новое дерево становится активным). Пользовательские ключи задаются в PARSER.KEYS */
--                 [M] bool Add( table itemParams, bool Enters, bool Spaces, table includeKeysForSort )         /* Добавляет новый item в дерево. bool Enters добавляет пробелы (отступы) сверху добавляемых объектов. bool Spaces добавляет пробелы (отступы) между значениями добавляемых объектов. Сортирует новые ключи параметров сверху вниз, если указаны. Сортируемые ключи по умолчанию определяются классом нового элемента */
--                 [M] bool Remove( table itemParams or "self")       /* Удаляет item в дереве. Укажите аргументом строку "self" для удаления дерева TREE (активного дерева) */ 
--                 [M] string GetName()        /* Возвращает имя тега дерева */
--                 [M] string GetObjName()     /* Возвращает Name дерева */
--                 [M] ??? GetCustomValue()    /* Возвращает _customValue дерева */
--                 [M] bool SetParam( const char* ParameterName, const CStr& ParameterValue )      /* Устанавливает новое значение параметра дерева */
--                 [M] AIParam GetParam( const char* ParameterName )    /* Возвращает значение параметра дерева. Имеются интерпретации значения: [.AsInt] - возвращает целое число, [.AsString] - возвращает строку, [.AsFloat] - возвращает число с запятой, [.AsBoolean] - возвращает логическое значение, [.AsRUchars] - возвращает строку с переведенными английскими буквами на русские буквы, [.AsENchars] - возвращает строку с переведенными русскими буквами на английские буквы */
--                 [M] int GetParamsAmount()    /* Возвращает количество параметров дерева */
--                 [M] bool AddParam( const char* ParameterName, const CStr& ParameterValue, bool Spaces )       /* Добавляет новый параметр дерева. bool Spaces добавляет пробелы (отступы) между значениями добавляемого параметра */
--                 [M] bool RemoveParam( const char* ParameterName )        /* Удаляет параметр дерева */
--                 [M] table GetObjectByCustomKey( string CustomKey )       /* Возвращает первый найденный объект дерева по пользовательскому параметру. Пользовательские ключи задаются в PARSER.KEYS */
--                 [M] table GetObjectByName( const char* ItemObjName )     /* Возвращает первый найденный объект дерева по Name */
--                 [M] table GetObjectById( const int* Id )         /* Возвращает первое найденный объект дерева по айди */
--                 [M] table GetObject( const char* ItemName )      /* Возвращает первый найденный объект дерева по тегу */
--                 [M] table GetTreeByCustomKey( string CustomKey )        /* Возвращает первое найденное дерево по пользовательскому параметру. Пользовательские ключи задаются в PARSER.KEYS */
--                 [M] table GetTreeByName( const char* TreeObjName )      /* Возвращает первое найденное дерево по Name внутри дерева */
--                 [M] table GetTreeById( const int* Id )          /* Возвращает первое найденное дерево по айди внутри дерева */
--                 [M] table GetTree( const char* TreeName )       /* Возвращает первое найденное дерево по тегу внутри дерева */
--                 [M] int GetItemsAmount()     /* Возвращает количество items дерева */
--                 [M] int GetChildsAmount()    /* Возвращает количество подобъектов дерева */
--                 [M] table GetParams()    /* Возвращает все параметры дерева */
--                 [M] table GetItems()     /* Возвращает все items дерева */
--                 [M] table GetChilds()    /* Возвращает все items дерева, имеющие подобъекты внутри себя */
--                 [M] bool Wrap()       /* Сворачивает выбранное дерево */
--                 [M] bool Unwrap()     /* Разворачивает выбранное дерево */
--                 [M] bool WrapAllItems()       /* Сворачивает все items дерева */
--                 [M] bool UnwrapAllItems()     /* Разворачивает все items дерева */
--                 [M] bool AddEnters()          /* Добавляет отступы между элементами, если нет */
--                 [M] bool CleanEnters()        /* Убирает отступы между элементами, если есть */
--                 [M] string AddAsTextField( const table* fieldParams, string TextFieldValue, bool Enters )    /* Добавляет fieldParams дерево как поле текста со значением TextFieldValue. Делает отсупы если Enters = true */
--                 [M] string ReadAsTextField( const table* fieldParams, bool CutTabs )       /* Возвращает содержимое между тегами дерева, ищет по fieldParams. Удаляет табуляцию в возвращаемом значении, если CutTabs = true */
--                 [M] string EditAsTextField( const table* fieldParams, string TextFieldNewValue )         /* Редактирует fieldParams дерево как поле текста с новым значением TextFieldNewValue */
--
--
--                 Class OBJ
--                 {
--                     [M] OBJ GetObj( table ObjectTagXorCustomKey, string CustomKeyValue ) : public TREE       /* Это прямое обращение к объекту OBJ: [{"TagName", "Name"}, "bibka"]. Пользовательские ключи задаются в PARSER.KEYS */
--                     {
--                         [M] string GetName()         /* Возвращает имя тега объекта */
--                         [M] string GetObjName()      /* Возвращает Name объекта */
--                         [M] AIParam GetProperty( const char* PropertyName )     /* Возвращает значение параметра объекта. Имеются интерпретации значения: [.AsInt] - возвращает целое число, [.AsString] - возвращает строку, [.AsFloat] - возвращает число с запятой, [.AsBoolean] - возвращает логическое значение, [.AsRUchars] - возвращает строку с переведенными английскими буквами на русские буквы, [.AsENchars] - возвращает строку с переведенными русскими буквами на английские буквы */
--                         [M] table GetProperties()                               /* Возвращает все параметры объекта */
--                         [M] bool SetProperty( const char* PropertyName, const CStr& PropertyValue )                 /* Устанавливает новое значение параметра объекта */
--                         [M] bool AddProperty( const char* PropertyName, const CStr& PropertyValue, bool Spaces )    /* Добавляет новый параметр объекта. bool Spaces добавляет пробелы (отступы) между значениями добавляемого параметра */
--                         [M] bool RemoveProperty( const char* PropertyName )       /* Удаляет параметр объекта */
--                         [M] string GetParentName()        /* Возвращает имя тега родительского дерева */
--                         [M] bool Wrap()       /* Сворачивает выбранный объект */
--                         [M] bool Unwrap()     /* Разворачивает выбранный объект */
--                     }
--                 }
--             }
--         }
--     
--        /* Экспериментальная ветка скриптов. Позволяет управлять триггерами других карт */
--        Class TRIGGER
--        {
--            [M] TRIGGER trigger( string TriggerName ) : public XMLParser     /* Это прямое обращение к триггеру TRIGGER. Используйте [XMLParser:init()] перед выполнением команд */
--            {
--                [M] bool Add( self, int Active, table Events, table Script)      /* Добавляет триггер с именем TriggerName, ивентами Events и скриптом Script. Events и Script это таблицы, содержащие отдельные строки, где каждая строка это строка скрипта/объекта ивента */
--                [M] bool Remove()        /* Удаляет триггер с именем TriggerName */
--                [M] bool DoScript()      /* Безопасно выполняет скрипт триггера. Возвращает вторым значением ошибку в противном случае. Глобальные игровые методы trigger недоступны - пожалуйста, откажитесь от методов или переопределяйте trigger внутри скрипта триггера, чтобы DoScript() выполнился корректно. В противном случае в скрипте триггера есть ошибка. Помните, что манипулирование объектами на других картах извне невозможно */
--                [M] bool IsActive()      /* Возвращает состояние триггера */
--                [M] bool SetActive( bool Active )     /* Назначает состояние триггера */
--                [M] string GetBody()     /* Возвращает скрипт триггера как строку */
--                [M] table GetScript()    /* Возвращает скрипт триггера как строковую таблицу */
--                [M] string GetScriptByLine( self, int Line )            /* Возвращает строку скрипта триггера по номеру строки (относительно) */
--                [M] int GetLineByScriptContent( self, string Content )  /* Возвращает номер строки скрипта триггера по содержимому строки (относительно) */
--                [M] bool ReplaceScript( self, string NewScript )        /* Заменяет скрипт триггера новым скриптом [[]] */
--                [M] bool AddScript( self, string Script, int Line )     /* Добавляет новую часть скрипта в триггер с позицией Line, иначе в конец триггера */
--                [M] void RemoveScript()     /* Удаляет скрипт триггера */
--                [M] bool RemoveScriptLine( self, int Line or string Content )     /* Удаляет строку скрипта триггера по номеру строки или по содержимому (относительно) */
--                [M] table GetAllEvents()    /* Возвращает все ивенты триггера. Ключами ивентов могут быть: [eventid], [timeout], [ObjName], [msgid], [flypath] */
--                [M] event[table] GetEventById( self, const char* EventId )                        /* Возвращает ивент триггера по имени eventid. Ключами ивентов могут быть: [eventid], [timeout], [ObjName], [msgid], [flypath] */
--                [M] event[table] GetEventByKey( self, const char* EventKey, string EventValue )   /* Возвращает ивент триггера по ключу ивента и его значению. Ключами ивентов могут быть: [eventid], [timeout], [ObjName], [msgid], [flypath] */
--                [M] bool AddEvent( table event )        /* Добавляет новый ивент в триггер. Ключами ивентов могут быть: [eventid], [timeout], [ObjName], [msgid], [flypath] */
--                [M] bool RemoveEvent( table event )     /* Удаляет ивент из триггера. Ключами ивентов могут быть: [eventid], [timeout], [ObjName], [msgid], [flypath] */
--            }
--        }
--     }
-- ]]
--
---------------------------------------------------------------
--
--------------- \/ Пример использования методов \/ -------------
--
-- lua
-- [[
--     local XMLParser = g_XMLParser    --> Получаем объект парсера lua-модуля, загруженного с помощью кода выше
--     if XMLParser then
--         local success, file = XMLParser:init('data\\gamedata\\my_xml_file.xml', "RootTagName", nil, false)   --> Инициализируем точку входа парсера в файл с заданным корневым тегом "RootTagName" или любым другим желаемым - "указатель" парсера захватит желаемое дерево
--         if success then
--             println("file exists")
--             local tree = XMLParser:Tree({"Repository", "My Items"}):init()   --> Инициализируем дерево с тегом "Repository" и параметром имени "My Items" внутри "RootTagName"
--             if tree then     --> Проверяем, существует ли такое дерево в файле
--                 println("tree exists")
--                 local getTree = XMLParser:Tree()                     --> Добавляем дерево в локальную переменную
--                 local getItem = getTree:GetObj({"Item", "Item01"})   --> Пытаемся получить объект с тегом "Item" и именем "Item01" в этом дереве
--                 if getItem then      --> Проверяем, существует ли такой объект
--                     println("item exists")
--                     local getItemParameter = getItem:GetProperty("MyParameterName").AsString        --> Пытаемся получить параметр "MyParameterName" этого объекта в виде строки
--                     println("parameter value: "..tostring(getItemParameter))        --> Принт значения этого параметра в консоль
--                 end
--             end
--             file:close()     --> Вручную закрываем файл, так как мы только узнали оттуда информацию и ничего не изменили. Не закрыть файл нельзя - он будет оставаться в памяти игры и другие программы не смогут получить к нему доступ. Если бы меняли, использовали бы [XMLParser:save()] - он и сохранит и закроет файл
--         end
--     end
-- ]]
--
---------------------------------------------------------------
--
-- ============= ОБРАЗЕЦ Params ДЕРЕВА/ОБЪЕКТА ================
--
-- lua
-- [[
--      local itemParams = {                /* Это таблица с ключами */
--           _itemClass = "tree",           --> Обязательный параметр. _itemClass задает сущность item. "tree" - для дерева, "object" - для объекта.
--           _itemTag = "TreeExample",      --> Обязательный параметр. _itemTag задает имя открывающего тега item (и закрывающего для дерева).
--           Name = "Example"               --> Необязательный, но очень рекомендуемый параметр. Ключевое значение, такое как (Name, name, ObjectId, Id, id) задает имя item внутри тегов. Незаменим для правильного поиска среди одинаковых тегов у объектов.
--      }                                   --> Ниже могут быть любые другие параметры без нижнего подчеркивания. Название параметра может быть любым буквенным ключом, значение параметра - строка.
-- ]]
--
-- lua                                               | lua
-- [[                                                | [[
--      local treeParams = {                         |       local objectParams = {
--          _itemClass = "tree",                     |           _itemClass = "object", 
--          _itemTag = "TreeExample",                |           _itemTag = "Object",
--          Name = "Example",                        |           ObjectId = "627",
--          Param1 = "6",                            |           Description = "huy",
--          Param2 = "true",                         |           Param3 = "true",
--          Description = "jopa",                    |           Param4 = "value",
--      }                                            |       }
-- ]]                                                | ]]
--
---------------------------------------------------------------
--
---------------------- Что такое "дерево" ---------------------
--
-- Class TREE команды.
--
-- xml                                               |   xml
-- [[                                                |   [[
--      <RootTree>      --> Открывающий тег          |           <TreeExample Name="Tree">
--      </RootTree>     --> Закрывающий тег          |           </TreeExample>
-- ]]                                                |   ]]
--                                                   |
-- xml                                               |   xml
-- [[                                                |   [[
--      <Repository                                  |           <Aboba>       --> Плохой пример дерева без уникального параметра имени или айди
--          Name="Пример"                            |           </Aboba>        
--          Description="I am a tree">               |   ]]        
--      </Repository>                                |           
-- ]]                                                |   
--
---------------------------------------------------------------
--
---------------------- Что такое "поле текста" ---------------------
--
-- Class TREE команды.
--
-- xml                                               |   xml
-- [[                                                |   [[
--      <Key>           --> Открывающий тег          |           <Key Name="Field">64</Key>
--      </Key>          --> Закрывающий тег          |   ]]       
-- ]]                                                |   
--                                                   |
-- xml                                               |   xml
-- [[                                                |   [[
--      <Key Name="Текст">Первая строка текста       |           <Key>       --> Плохой пример поля без уникального параметра имени или айди
--          Вторая строка текста                     |           </Key>        
--      </Key>                                       |   ]]        
--                                                   |           
-- ]]                                                |   
--
---------------------------------------------------------------
--
---------------------- Что такое "объект" ---------------------
--
-- Class OBJ команды.
--
-- xml                                               |   xml
-- [[                                                |   [[
--      <Ware                 --> Открывающий тег    |           <Item Id="666" Value="true" />              --> Объект 1
--          Name="Картошка"                          |           <Object Value="3" />                        --> Объект 2
--      />                    --> Закрывающий флажок |           <Entity Name="Параметр2" Value="false" />   --> Объект 3
-- ]]                                         (тег)  |   ]]
--                                                   |
-- xml                                               |   xml
-- [[                                                |   [[
--      <Ending                                      |           
--          Name="Спасибо за игру!"                  |           <Object />       --> Плохой пример объекта без уникального параметра имени или айди
--          Description="Complete game" />           |           
-- ]]                                                |   ]]
--
---------------------------------------------------------------
--
-- ======================== СОВЕТЫ ============================
--
--      Если вы читаете небольшие файлы, можете использовать
-- образец выше с [XMLParser:init()]. Его легко контролировать
-- и проводить всякие проверки.
--
--      Если вы читаете огромные файлы со сложной структурой,
-- настоятельно рекомендую рассмотреть вариант с "очередью":
-- [openQueue()] и [closeQueue()]. Он будет наиболее 
-- "оптимизированным" вариантом, который лучше справляется с 
-- большими файлами - игра заметно меньше страдает. Этот вариант
-- сложнее поддается на проверки.
--      Приведу несколько готовых скриптов-примеров:
--
-- lua
-- [[
--    --Получим XMLParser-объект игрока из сохранения и отдельно запишем ему новое значение денег
--    local path_to_savefile = 'data\\profiles\\Player\\saves\\00000000\\maps\\currentmap.xml'
--    XMLParser:openQueue( path_to_savefile )
--    local PLAYER = XMLParser:GetItemFromFile('Name%s*=%s*"Player1"', "Object", "DynamicScene")
--    XMLParser:SetItemValueInFile('Name%s*=%s*"Player1"', "Object", "DynamicScene", 'Money', '%d*', '99999999')
--    XMLParser:closeQueue()
-- ]]
--
-- lua
-- [[
--    --Изменим текст некоторых реплик из dialogsglobal.xml
--    local path_to_dialogsglobal = 'data\\if\\diz\\dialogsglobal.xml'
--    XMLParser:openQueue( path_to_dialogsglobal )
--    XMLParser:SetItemValueInFile('name%s*=%s*"Man_dlg0_1"', "Reply", "DialogsResource", "text", "текст для замены", "этот текст был заменен")
--    XMLParser:SetItemValueInFile('name%s*=%s*"Man_dlg0_2"', "Reply", "DialogsResource", "text", "текст для замены", "этот текст был заменен")
--    XMLParser:SetItemValueInFile('name%s*=%s*"Man_dlg1_1"', "Reply", "DialogsResource", "text", "текст для замены", "этот текст был заменен")
--    XMLParser:SetItemValueInFile('name%s*=%s*"Man_dlg2_3"', "Reply", "DialogsResource", "text", "текст для замены", "этот текст был заменен")
--    XMLParser:SetItemValueInFile('name%s*=%s*"Man_dlg2_4"', "Reply", "DialogsResource", "text", "текст для замены", "этот текст был заменен")
--    XMLParser:SetItemValueInFile('name%s*=%s*"Man_dlg3_0"', "Reply", "DialogsResource", "text", "текст для замены", "этот текст был заменен")
--    XMLParser:SetItemValueInFile('name%s*=%s*"Man_dlg4_3"', "Reply", "DialogsResource", "text", "текст для замены", "этот текст был заменен")
--    XMLParser:closeQueue()
--    if RepliesManager then
--	      RepliesManager:Init()
--	  end
-- ]]
--
-- lua
-- [[
--    --Найдем и удалим все ненужные объекты из world.xml
--    local path_to_world = 'data\\maps\\r1m1\\world.xml'
--    local tag = "Node"
--    local folder = "World"
--    local example = 'id%s*=%s*"big_stone4"'
--    XMLParser:openQueue( path_to_world )
--    local item = XMLParser:GetItemFromFile(example, tag, folder)
--	  if item then
--	   	  repeat
--	   	      item = XMLParser:RemoveItemFromFile(example, tag, folder)
--	   	  until not item
--	  end
--    XMLParser:closeQueue()
-- ]]
-- 
---------------------------------------------------------------
--
-- ======================= ПОДРОБНЕЕ ==========================
--
--
--      Эту и другую информацию вы сможете найти на github  
-- проекта или найти примеры работы парсера в моде ExplorerMod 
-- от того же автора.
--      Ссылка на github: https://github.com/ejetaxeblevich
--
---------------------------------------------------------------
--
-- =================== КОММЕНТАРИИ АВТОРА =====================
-- 
-- E Jet: Это заколдованный парсер в котором хочется срать.
--
-- E Jet: Благодарность за идею скрипта захвата атрибутов:
--                        stakanyash
-- 
-- ============================================================
-- ============================================================


-- //////////////////////////// MODULE INIT /////////////////////////////////


local XMLParser = {}
XMLParser.__index = XMLParser
XMLParser.version = "v1.0.1"
XMLParser.data = {}
local PARSER = XMLParser.data

LOG("[I] Init Module XMLParser.lua ...")


-- ////////////////////////// DEFAULT MODULE CONSTANTS //////////////////////////


PARSER.CLASSES = {"tree", "object", "item"}


PARSER.KEYS_Name = {"Name", "name"}
PARSER.KEYS_Id = {"ObjectId", "Id", "id"}
PARSER.KEYS_TriggerEvent = {"eventid", "timeout", "ObjName", "msgid", "flypath"}

PARSER.KEYS_SearchingGradient = {"Name", "name", "ObjectId", "Id", "id", "field", "_customValue"}
PARSER.KEYS_PriorityGradient = {"ObjectId", "Id", "id", "Name", "name", "field", "Value", "ListOfItems", "Chassis", "Cabin", "Cargo", "Skin", "ListOfGuns", "Status", "Item", "Amount", "Maximum", "Description", "Difficulty", "Done"}

PARSER.KEYS_FORBIDDEN = {_itemClass=1, _itemLine=1, _itemParent=1, _itemProperties=1, _itemTag=1}


-- ////////////////////////// DEFAULT MODULE ITEMS //////////////////////////


PARSER.treeExample = {
    _itemClass = "tree", 
    _itemTag = "TreeExample", 
    Name = "Example",
    Amount = "1",
    Maximum = "3",
    Description = "jopa",
}

PARSER.itemExample = {
    _itemClass = "object", 
    _itemTag = "Object", 
    Name = "obj",
    Description = "value",
    Param3 = "value3",
    Param4 = "value4",
}

PARSER.ModStats_Repo = {
    _itemClass = "tree",
    _itemTag = "Repository", 
    Name = "TestObjects",
    Amount = "2",
    Maximum = "3"
}
PARSER.ModStats_Endi = {
    _itemClass = "object",
    _itemTag = "Ending", 
    Name = "Выжить",
    Description = "Сохранить зрение",
    Done = "true" --false
}
PARSER.ModStats_Achi = {
    _itemClass = "object",
    _itemTag = "Achievement", 
    Name = "Я ебал в рот эти скрипты",
    Description = "Заставить работать конструктор химулей",
    Done = "false"
}


-- ///////////////////////////// LOCAL DEBUG FUNCTIONS ////////////////////////////


local function parserLOG(...)
    if PARSER.LOG then
        local logstr = {}
        for i, v in ipairs(arg) do
            if arg[i+1] then
                v = tostring(v).."\t"
            end
            table.insert(logstr, tostring(v))
        end
        LOG("[XMLParserLOG]: "..table.concat(logstr))
    end
end
local function parserPRINT(...)
    if PARSER.LOG then
        local printstr = {}
        for i, v in ipairs(arg) do
            if arg[i+1] then
                v = tostring(v).."\t"
            end
            table.insert(printstr, tostring(v))
        end
        println("[XMLParserPRINT]: "..table.concat(printstr))
    end
end


local function _TableToString(tbl, indent)
    parserLOG(":::: local function _TableToString ::::")
    if type(tbl)~="table" then 
        return ""..tostring(tbl) 
    end
    indent = indent or 0
    local result = ""
    for key, value in pairs(tbl) do
        if type(value) == "table" then
            result = result .. string.rep(" ", indent) .. key .. " = {\n" .. _TableToString(value, indent + 4) .. string.rep(" ", indent) .. "}\n"
        else
            result = result .. string.rep(" ", indent) .. key .. " = \"" .. tostring(value) .. "\"\n"
        end
    end
    return result
end


-- ///////////////////// DEFAULT MODULE VARS /////////////////////////


function XMLParser:clearCache()
    parserLOG(":::: global method XMLParser:clearCache ::::")
    parserLOG("Note: LOG is done. Please, use bLOG in XMLParser:init() for see parser LOG")
    
    PARSER.PATH = "data\\gamedata\\file_name.xml"

    PARSER.ROOT = "Main"

    PARSER.XML = '<?xml version="1.0" encoding="windows-1251" standalone="yes" ?>\n<'..tostring(PARSER.ROOT)..'>\n</'..tostring(PARSER.ROOT)..'>'

    PARSER.LOG = false

    PARSER.ENTERS = false
    PARSER.SPACES = false

    PARSER.OPENEDFILEDESCRYPTOR = nil
    PARSER.AUTOUPDATE = false
    PARSER.TREEDATA = {}
    PARSER.TREEPARAMS = {}
    PARSER.FILEDATA = {}
    PARSER.CACHEDFILEDATA = nil
    PARSER.TREEFIRSTLINE = nil
    PARSER.TREELASTLINE = nil

    PARSER.CACHE_TREEPARAMS = nil
end

XMLParser:clearCache()



function XMLParser:getCache()
    parserLOG(":::: global method XMLParser:getCache ::::")

    LOG("[I] Module XMLParser.lua === Call current module cache...")
    local i = 1
    local cache = {}
    for k,v in pairs(PARSER) do
        LOG("[I] ["..i.."] PARSER."..tostring(k).." is {"..tostring(v).."}")
        table.insert(cache, v)
        i=i+1
    end

    parserLOG(":::: ^^^^ global method XMLParser:getCache ^^^^ ::::")

    return cache
end



-- ///////////////////////////// LOCAL FUNCTIONS ////////////////////////////



local function TranslateRUCharsToENChars(text)
    parserLOG(":::: local function TranslateRUCharsToENChars ::::")
    local translitTable = {
        ['а'] = 'a', ['б'] = 'b', ['в'] = 'v', ['г'] = 'g', ['д'] = 'd',
        ['е'] = 'e', ['ё'] = 'yo', ['ж'] = 'zh', ['з'] = 'z', ['и'] = 'i',
        ['й'] = 'y', ['к'] = 'k', ['л'] = 'l', ['м'] = 'm', ['н'] = 'n',
        ['о'] = 'o', ['п'] = 'p', ['р'] = 'r', ['с'] = 's', ['т'] = 't',
        ['у'] = 'u', ['ф'] = 'f', ['х'] = 'h', ['ц'] = 'ts', ['ч'] = 'ch',
        ['ш'] = 'sh', ['щ'] = 'sch', ['ъ'] = '', ['ы'] = 'y', ['ь'] = '',
        ['э'] = 'e', ['ю'] = 'yu', ['я'] = 'ya',

        ['А'] = 'A', ['Б'] = 'B', ['В'] = 'V', ['Г'] = 'G', ['Д'] = 'D',
        ['Е'] = 'E', ['Ё'] = 'Yo', ['Ж'] = 'Zh', ['З'] = 'Z', ['И'] = 'I',
        ['Й'] = 'Y', ['К'] = 'K', ['Л'] = 'L', ['М'] = 'M', ['Н'] = 'N',
        ['О'] = 'O', ['П'] = 'P', ['Р'] = 'R', ['С'] = 'S', ['Т'] = 'T',
        ['У'] = 'U', ['Ф'] = 'F', ['Х'] = 'H', ['Ц'] = 'Ts', ['Ч'] = 'Ch',
        ['Ш'] = 'Sh', ['Щ'] = 'Sch', ['Ъ'] = '', ['Ы'] = 'Y', ['Ь'] = '',
        ['Э'] = 'E', ['Ю'] = 'Yu', ['Я'] = 'Ya'
    }

    local result = ''

    for i = 1, string.len(text) do
        local char = string.sub(text, i, i)
        if translitTable[char] then
            result = result .. translitTable[char]
        else
            result = result .. char
        end
    end

    return result
end


local function TranslateENCharsToRUChars(text)
    parserLOG(":::: local function TranslateENCharsToRUChars ::::")
    local reverseTranslitTable = {
        ['a'] = 'а', ['b'] = 'б', ['v'] = 'в', ['g'] = 'г', ['d'] = 'д',
        ['e'] = 'е', ['yo'] = 'ё', ['zh'] = 'ж', ['z'] = 'з', ['i'] = 'и',
        ['y'] = 'й', ['k'] = 'к', ['l'] = 'л', ['m'] = 'м', ['n'] = 'н',
        ['o'] = 'о', ['p'] = 'п', ['r'] = 'р', ['s'] = 'с', ['t'] = 'т',
        ['u'] = 'у', ['f'] = 'ф', ['h'] = 'х', ['ts'] = 'ц', ['ch'] = 'ч',
        ['sh'] = 'ш', ['sch'] = 'щ', [''] = 'ъ', ['y'] = 'ы', [''] = 'ь',
        ['e'] = 'э', ['yu'] = 'ю', ['ya'] = 'я',

        ['A'] = 'А', ['B'] = 'Б', ['V'] = 'В', ['G'] = 'Г', ['D'] = 'Д',
        ['E'] = 'Е', ['Yo'] = 'Ё', ['Zh'] = 'Ж', ['Z'] = 'З', ['I'] = 'И',
        ['Y'] = 'Й', ['K'] = 'К', ['L'] = 'Л', ['M'] = 'М', ['N'] = 'Н',
        ['O'] = 'О', ['P'] = 'П', ['R'] = 'Р', ['S'] = 'С', ['T'] = 'Т',
        ['U'] = 'У', ['F'] = 'Ф', ['H'] = 'Х', ['Ts'] = 'Ц', ['Ch'] = 'Ч',
        ['Sh'] = 'Ш', ['Sch'] = 'Щ', [''] = 'Ъ', ['Y'] = 'Ы', [''] = 'Ь',
        ['E'] = 'Э', ['Yu'] = 'Ю', ['Ya'] = 'Я'
    }

    local result = ''

    local i = 1

    while i <= string.len(text) do
        local twoChar = string.sub(text, i, i + 1)
        local twoCharLower = string.lower(twoChar)
        if reverseTranslitTable[twoCharLower] then
            result = result .. reverseTranslitTable[twoCharLower]
            i = i + 2
        else
            local oneChar = string.sub(text, i, i)
            local oneCharLower = string.lower(oneChar)
            if reverseTranslitTable[oneCharLower] then
                result = result .. reverseTranslitTable[oneCharLower]
            else
                result = result .. oneChar
            end
            i = i + 1
        end
    end

    return result
end


local function is_file_exists(path)
    local b = false
	local f = io.open(path, 'r')
	if f then
		b = true
		f:close()
	end
    return b
end

local function is_file_open(f)
    if type(f) ~= "userdata" then
        return false
    end

    local ok, err = pcall(function() return f:seek() end)
    return ok
end

local function array_equal(t1, t2)
    if getn(t1) ~= getn(t2) then return false end
    for i = 1, getn(t1) do
        if t1[i] ~= t2[i] then return false end
    end
    return true
end

local function update_array_ordered(new_array)
    local new_len = getn(new_array)
    local result = PARSER.CACHEDFILEDATA
    local i = 1

    if not result then
        return nil
    end

    --перебираем new_array и ставим элементы на соответствующие позиции в result
    while i <= new_len do
        if result[i] == new_array[i] then
            --элемент совпадает - идем дальше
            i = i + 1
        else
            --если в result элемент другой, ищем нужный в остатке и переставляем,
            --либо вставляем новый

            --пытаемся найти new_array[i] в result дальше
            local found_pos = nil
            for j = i + 1, getn(result) do
                if result[j] == new_array[i] then
                    found_pos = j
                    break
                end
            end

            if found_pos then
                --удаляем элемент с позиции found_pos и вставляем на i
                local val = table.remove(result, found_pos)
                table.insert(result, i, val)
                i = i + 1
            else
                --элемента нет, вставляем новый
                table.insert(result, i, new_array[i])
                i = i + 1
            end
        end
    end

    parserLOG("compile")

    --удаляем лишние элементы в конце result
    while getn(result) > new_len do
        table.remove(result)
    end

    PARSER.CACHEDFILEDATA = result

    return result
end


local function GetRootTagInFile(content, root_tag_in_file)
    parserLOG(":::: local function GetRootTagInFile ::::")
    local root_tag_in_file = root_tag_in_file or ""
    local content = content or PARSER.CACHEDFILEDATA or PARSER.FILEDATA or {}

    PARSER.CACHEDFILEDATA = content

    local fast_content = table.concat(content)
    if (string.find(fast_content, "<"..root_tag_in_file..">?")) and (string.find(fast_content, "</"..root_tag_in_file..">")) then
        return true, file
    end

    return nil
end


local function GetItemKey(itemParams, tableKeys)
    for i,k in ipairs(tableKeys or {}) do
        if itemParams[k] and not PARSER.KEYS_FORBIDDEN[k] then
            return k, itemParams[k]
        end
    end
end

local function IsKeyForbidden(key)
    if PARSER.KEYS_FORBIDDEN[key or ""] then
        return true
    end
end

local function CopyItemParams(itemParams)
    local copied_params = {}
    for k,v in pairs(itemParams) do
        copied_params[k] = v
    end
    return copied_params
end


local function CollectContentTable(new_content)
    parserLOG(":::: local function CollectContentTable ::::")
    return update_array_ordered(new_content)
end



local function WriteXMLParserFileForTable(content)
    parserLOG(":::: local function WriteXMLParserFileForTable ::::")
    if (not content) or (not type(content)=="table") then 
        return nil 
    end
    local path_to_file = PARSER.PATH

    local file = PARSER.OPENEDFILEDESCRYPTOR
    pcall(function() return file:close() end)

    file = io.open(path_to_file, "w")
    PARSER.OPENEDFILEDESCRYPTOR = file

    if not file then
        PARSER.OPENEDFILEDESCRYPTOR = nil
        return nil
    end

    file:seek("set",0)
    local l=1
    while content[l]~=nil do
        file:write(content[l].."\n")
        l=l+1
    end
    file:close()

    PARSER.OPENEDFILEDESCRYPTOR = nil
    PARSER.CACHEDFILEDATA = nil

    parserLOG("writttt")

    return true
end


local function PackStringFromTable(tbl, bRemoveTABS)
    parserLOG(":::: local function PackStringFromTable ::::")
    local retVal = ""
    local savedTabs = ""
    if type(tbl)=="table" then 
        for i, v in ipairs(tbl) do
            if i==1 then
                local _,_,savedTabsssss = string.find(v, "(\t*)")
                if savedTabsssss then savedTabs = savedTabsssss end
                retVal = retVal .. "" .. v
            else
                retVal = retVal .. " " .. v
            end
        end
    else
        return tostring(tbl) 
    end
    if bRemoveTABS then
        retVal = string.gsub(retVal, "[\t*]", "")
    end
    retVal = savedTabs..retVal
    return retVal
end


local function PackTableFromString(input_string)
    local result = {}
    local start = 1
    while start <= string.len(input_string) do
        local _, next_pos, line = string.find(input_string, "([^\n]*)\n?", start)
        if line then
            table.insert(result, line)
            start = next_pos + 1
        else
            break
        end
    end
    return result
end


local function UnwrapItemForCommentLines(comment)
    parserLOG(":::: local function UnwrapItemForCommentLines ::::")
    local commentExample = [[       <Comment line1="1" line2="2" line3="3" />]]
    local slicedCommentExample = [[       <Comment 
    line1="1"
    line2="2"
    line3="3"
    />]] --\n
    --[[
        lines = {
            '<Comment line1="1",',
            'line2="2",',
            'line3="3",',
        }
    ]]

    local findParamPattern = '[^<\t]*%s*=+%s*"[^"]*"'

    local savedTabs = ""
    local _, _, savedTabss = string.find(comment, "(\t*)<")
    if savedTabss then
        savedTabs = savedTabss
    end
    
    local comment = comment or commentExample

    comment = string.gsub(comment, '<([%w]*)%s+', '<%1\n')
    comment = string.gsub(comment, '"%s+', '"\n')
    comment = string.gsub(comment, '</([.]*)', '\n</%1')
    comment = string.gsub(comment, '>[^<]*<([.]*)', '>\n'..savedTabs..'\t<%1')
    comment = string.gsub(comment, '\n%s*/>', ' />')
    
    local lines = {}
    local start_pos = 1

    while true do
        local end_pos = string.find(comment, "\n", start_pos)
        if not end_pos then
            break
        end
        local line = string.sub(comment, start_pos, end_pos - 1)
        line = ""..line
        if lines[1] then
            line = savedTabs.."\t"..line
        end
        table.insert(lines, line)
        start_pos = end_pos + 1
    end

    if start_pos <= string.len(comment) then
        local last_line = string.sub(comment, start_pos)
        if lines[1] then
            last_line = savedTabs.."\t"..last_line
        else
            last_line = ""..last_line
        end
        table.insert(lines, last_line)
    end

    return lines
end


local function SliceParamsForCommentLines(comment)
    parserLOG(":::: local function SliceParamsForCommentLines ::::")
    local commentExample = [[       <Comment line1="1" line2="2" line3="3" />]]
    local slicedCommentExample = [[<Comment line1="1",
    line2="2",
    line3="3",
    />]] --\n
    --[[
        lines = {
            '<Comment line1="1",',
            'line2="2",',
            'line3="3",',
        }
    ]]
    
    local comment = comment or commentExample

    comment = string.gsub(comment, '"%s+', '",\n')
    comment = string.gsub(comment, '[\t*]', '')
    
    local lines = {}
    local start_pos = 1

    while true do
        local end_pos = string.find(comment, "\n", start_pos)
        if not end_pos then
            break
        end
        local line = string.sub(comment, start_pos, end_pos - 1)
        line = " "..line
        table.insert(lines, line)
        start_pos = end_pos + 1
    end

    if start_pos <= string.len(comment) then
        local last_line = string.sub(comment, start_pos)
        last_line = " "..last_line
        table.insert(lines, last_line)
    end

    return lines
end


local function getLineNumberFromSymbolPosition(content, charPosition)
    parserLOG(":::: local function getLineNumberFromSymbolPosition ::::")
    local lineNumber = 1
    for i = 1, charPosition do
        if string.sub(content, i, i) == "\n" then
            lineNumber = lineNumber + 1
        end
    end
    return lineNumber
end


local function CheckXMLParserFileForTree(treeParams, bNotReturnContent)
    parserLOG(":::: local function CheckXMLParserFileForTree ::::")
    local treeParams = treeParams or PARSER.treeExample

    local tree_name
    local tree_objName
    --local tree_key
    if type(treeParams)~="table" then
        tree_name = treeParams or PARSER.ROOT
        tree_objName = nil
    else
        tree_name = treeParams["_itemTag"] or PARSER.ROOT
        _, tree_objName = GetItemKey(treeParams, PARSER.KEYS_SearchingGradient)
    end

    local content = PARSER.CACHEDFILEDATA or PARSER.FILEDATA or {}
    local fast_content = table.concat(content)

    if not (string.find(fast_content, "<"..tree_name.."(\n*)")) or not (string.find(fast_content, "</"..tree_name..">")) then
        LOG("[E] Module XMLParser.lua === Tree <"..tree_name.."> in '"..PARSER.PATH.."' not found")
        parserPRINT("Tree <"..tree_name.."> in '"..PARSER.PATH.."' not found")
        return nil
    end

    local firstLine, lastLine = 0, 0
    for i, value in ipairs(content) do
        if string.find(value, "<"..tree_name) then
            firstLine = i+1
        elseif string.find(value, "</"..tree_name..">") then
            lastLine = i+1
            break
        end
    end

    if (tree_objName) and (tree_objName~="") then
        parserLOG("\\\\ "..tree_objName)
        --local gdeStart, gdeEnd, fnd_tree_objName = string.find(fast_content, "<"..tree_name..'[^>]*'..tostring(tree_key)..'%s*=%s*"'..tree_objName..'"')
        local gdeStart, gdeEnd = string.find(fast_content, '<'..tree_name..'[^<]*=%s*"'..tree_objName..'"[^>]*>')
        parserLOG(gdeStart, gdeEnd, tree_name, tree_objName)
        if gdeStart then
            local ankerTree = string.sub(fast_content, gdeStart, gdeEnd)
            parserLOG("{"..ankerTree.."}")
            firstLine = getLineNumberFromSymbolPosition(fast_content, gdeStart)
            lastLine = firstLine
            while string.find(content[lastLine], "</"..tree_name..">")==nil do
                --parserLOG("<> "..content[lastLine])
                lastLine = lastLine + 1
            end
            parserLOG(">>> "..content[firstLine])
            parserLOG(">>> "..content[lastLine])
            parserLOG("[I] Module XMLParser.lua === Finded tree <"..tree_name.."> in '"..PARSER.PATH.."' with name \""..tree_objName.."\", "..gdeStart..";"..gdeEnd)
            parserPRINT("Finded tree <"..tree_name.."> in '"..PARSER.PATH.."' with name \""..tree_objName.."\", "..gdeStart..";"..gdeEnd)
        end
    end

    if bNotReturnContent then
        content = nil
    end
    return fast_content, content, firstLine, lastLine
end


local function CheckItemClass(put_inParams, itemParams, whoChecker)
    parserLOG(":::: local function CheckItemClass ::::")
    local whoChecker = whoChecker or {}
    local put_in = put_inParams["_itemClass"] or "tree"
    if not itemParams["_itemClass"] then
        LOG("[E] Module XMLParser.lua === Attempt to check unknown class item for \""..put_in.."\" in '"..PARSER.PATH.."'")
        error("XMLParser: Attempt to check unknown class item for \""..put_in.."\" in '"..PARSER.PATH.."'")
        return nil
    end
    local classExists, i = false, 1
    while PARSER.CLASSES[i]~=nil do
        if PARSER.CLASSES[i]==itemParams["_itemClass"] then
            classExists = true
        end
        i=i+1
    end
    if not classExists then
        LOG("[E] Module XMLParser.lua === Attempt to check unknown class item for \""..put_in.."\" in '"..PARSER.PATH.."'")
        error("XMLParser: Attempt to check unknown class item for \""..put_in.."\" in '"..PARSER.PATH.."'")
        return nil
    end
    i=1
    while whoChecker[i]~=nil do
        if itemParams["_itemClass"]==whoChecker[i] then
            LOG("[E] Module XMLParser.lua === Attempt to check conflict class item for \""..put_in.."\" in '"..PARSER.PATH.."'")
            error("XMLParser: Attempt to check conflict class item for \""..put_in.."\" in '"..PARSER.PATH.."'")
            return nil
        end
        i=i+1
    end
    return true
end


local function CheckXMLParserFileTreeForItem(treeParams, itemParams)
    parserLOG(":::: local function CheckXMLParserFileTreeForItem ::::")
    local treeParams = treeParams or PARSER.treeExample
    local itemParams = itemParams or PARSER.itemExample

    local put_in = treeParams
    if not CheckItemClass(put_in, itemParams) then
        return nil
    end

    local _, itemParamForSearch = GetItemKey(itemParams, PARSER.KEYS_SearchingGradient)

    local treeData, content, firstLine, lastLine = XMLParser:getTree(treeParams)
    local item = 1
    local items = treeData[2]
    if items then
        local itemssss = treeData[2][item]
        if itemssss then
            while treeData[2][item]~=nil do
                local Obj = treeData[2][item]["_itemTag"]
                local ObjClass = treeData[2][item]["_itemClass"]
                local _, ObjParamForSearch = GetItemKey(treeData[2][item]["_itemProperties"], PARSER.KEYS_SearchingGradient)
                if (itemParams["_itemClass"]=="tree") and ((Obj==itemParams["treeName"]) and (ObjParamForSearch==itemParamForSearch) and (ObjClass==itemParams["_itemClass"])) then
                    parserLOG("[E] Module XMLParser.lua === "..tostring(itemParams["_itemTag"]).." with class '"..tostring(itemParams["_itemClass"]).."' and value \""..tostring(itemParamForSearch).."\" in tree <"..tostring(treeName).."> '"..PARSER.PATH.."' already exists")
                    parserPRINT("[E] Module XMLParser.lua === "..tostring(itemParams["_itemTag"]).." with class '"..tostring(itemParams["_itemClass"]).."' and value \""..tostring(itemParamForSearch).."\" in tree <"..tostring(treeName).."> '"..PARSER.PATH.."' already exists")
                    return true, itemParams, content, firstLine, lastLine 
                end
                item=item+1
            end
        end
    end

    return nil, itemParams, content, firstLine, lastLine 
end


local function CheckXMLParserFileTreeForTree(treeParams_put_in, treeParams)
    parserLOG(":::: local function CheckXMLParserFileTreeForTree ::::")
    local treeParams_put_in = treeParams_put_in or PARSER.ROOT
    local treeParams = treeParams or PARSER.treeExample

    local _, treeParamForSearch = GetItemKey(treeParams, PARSER.KEYS_SearchingGradient)

    local treeData, content, firstLine, lastLine = XMLParser:getTree(treeParams_put_in)
    local tree = 1
    local trees = treeData[2]
    if trees then
        local treessss = treeData[2][tree]
        if treessss then
            while treeData[2][tree]~=nil do
                local Obj = treeData[2][tree]["_itemTag"]
                local ObjClass = treeData[2][tree]["_itemClass"]
                local _, ObjParamForSearch = GetItemKey(treeData[2][item]["_itemProperties"], PARSER.KEYS_SearchingGradient)
                if (treeParams["_itemClass"]=="tree") and ((Obj==treeParams["treeName"]) and (ObjParamForSearch==treeParamForSearch) and (ObjClass==treeParams["_itemClass"])) then
                    parserLOG("[E] Module XMLParser.lua === "..tostring(treeParams["_itemTag"]).." with value \""..tostring(treeParamForSearch).."\" in tree <"..tostring(treeName).."> '"..PARSER.PATH.."' already exists")
                    parserPRINT("[E] Module XMLParser.lua === "..tostring(treeParams["_itemTag"]).." with value \""..tostring(treeParamForSearch).."\" in tree <"..tostring(treeName).."> '"..PARSER.PATH.."' already exists")
                    return true, treeParams, content, firstLine, lastLine 
                end
                tree=tree+1
            end
        end
    end

    return nil, treeParams, content, firstLine, lastLine 
end



local function _CopyTable(orig)
    parserLOG(":::: local function _CopyTable ::::")
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[_CopyTable(orig_key)] = _CopyTable(orig_value)
        end
        setmetatable(copy, _CopyTable(getmetatable(orig)))
    else
        copy = orig
    end
    return copy
end



local function _INTERPRETATION(Value)
    parserLOG(":::: local function _INTERPRETATION ::::")
    local interpreters = {
        AsBoolean = function()
            if Value=="nil" then return nil end
            if Value=="true" then return true end
            if Value=="false" then return false end
            if Value=="" then return nil end
            if Value then return true else return nil end
        end,
        AsString = function()
            if not Value then Value = "nil" end
            local v = tostring(Value)
            if v then return v end
            return Value
        end,
        AsInt = function()
            if not Value then Value = 0 end
            local v = math.floor(tonumber(Value) or 0)
            if v then return v end
            return Value
        end,
        AsFloat = function()
            if not Value then Value = 0 end
            local v = tonumber(Value) or 0
            if v then return v end
            return Value
        end,
        AsENchars = function()
            if not Value then Value = "nil" end
            local v = tostring(Value)
            if v then v = TranslateRUCharsToENChars(v) end
            if v then return v end
            return Value
        end,
        AsRUchars = function()
            if not Value then Value = "nil" end
            local v = tostring(Value)
            if v then v = TranslateENCharsToRUChars(v) end
            if v then return v end
            return Value
        end
    }
    
    local metatable = setmetatable({}, {
        __index = function(_, key)
            local interpreter = interpreters[key]
            if interpreter then
                return interpreter()
            else
                return Value
            end
        end,
        __call = function()
            return Value
        end,
        __tostring = function()
            return tostring(Value)
        end
    })

    return metatable
end


local function ____table_contains(tbl, value)
    parserLOG(":::: local function ____table_contains ::::")
    for _, v in ipairs(tbl) do
        if v == value then
            return true
        end
    end
    return false
end




-- ///////////////////////////////////////////////////////////////////////////////

-- //////////////////////// GLOBAL MODULE FUNCTIONS //////////////////////////////

-- ///////////////////////////////////////////////////////////////////////////////



function XMLParser:IsFileExists(path_to_file)
    parserLOG(":::: global method XMLParser:IsFileExists ::::")
    return is_file_exists(path_to_file)
end

function XMLParser:IsFileOpen(fileDescryptor)
    parserLOG(":::: global method XMLParser:IsFileOpen ::::")
    return is_file_open(fileDescryptor)
end
    

--g_XMLParser:init()
function XMLParser:init(path_to_file, root_tag_in_file, default_file_content, bLog)
    parserLOG(":::: global method XMLParser:init ::::")
    local path_to_file = path_to_file or PARSER.PATH
    local default_file_content = default_file_content or PARSER.XML
    local root_tag_in_file = root_tag_in_file or PARSER.ROOT

    local file = PARSER.OPENEDFILEDESCRYPTOR
    if is_file_open(file) then
        pcall(function() return file:close() end)
        PARSER.OPENEDFILEDESCRYPTOR = nil
    end

    local content = XMLParser:openQueue(path_to_file)
    if not content then
        LOG("[E] Module XMLParser.lua === File '"..tostring(path_to_file).."' does not exists!")
        println("[E] Module XMLParser.lua === File '"..tostring(path_to_file).."' does not exists!")
        return nil
    end
    file = PARSER.OPENEDFILEDESCRYPTOR

    if bLog then
        PARSER.LOG = true
    else
        PARSER.LOG = false
    end

    local exists = GetRootTagInFile(content, root_tag_in_file)
    if not exists then
        LOG("[E] Module XMLParser.lua === File '"..tostring(path_to_file).."' without root tag <"..tostring(root_tag_in_file)..">")
        println("[E] Module XMLParser.lua === File '"..tostring(path_to_file).."' without root tag <"..tostring(root_tag_in_file)..">")
        return nil
    end

    PARSER.PATH = path_to_file
    PARSER.ROOT = root_tag_in_file
    PARSER.XML = default_file_content

    return true, file
end

function XMLParser:save()
    parserLOG(":::: global method XMLParser:save ::::")
    return XMLParser:closeQueue()
end


-- ///////////////////////////////////////////////////////////////////////////////


--g_XMLParser:createFile()
function XMLParser:createFile(path, default_file_content)
    parserLOG(":::: global method XMLParser:createFile ::::")
    local path = path or PARSER.PATH
    local file = io.open(path, "r")
    if not file then
        file = io.open(path, "w")
        local default_file_content = default_file_content or PARSER.XML
        if default_file_content then PARSER.XML = default_file_content end
        file:write(PARSER.XML)
        file:close()
        file = nil
        return true
    end
    file:close()
    return false
end

--g_XMLParser:removeFile()
function XMLParser:removeFile()
    parserLOG(":::: global method XMLParser:removeFile ::::")
    local path = PARSER.PATH
    local file = io.open(path, "r")
    if file then
        file:close()
        file = nil
        os.remove(path)
        return true
    end
    return false
end



--g_XMLParser:addTree({_itemClass = "tree", _itemTag = "ExampleTree2"}, "TreeExample")
function XMLParser:addTree(treeParams, put_in, includeKeysForSort)
    parserLOG(":::: global method XMLParser:addTree ::::")
    local treeParams = treeParams or PARSER.treeExample

    local treeObjName = treeParams["_itemTag"] or "Tree"

    put_in._itemClass = put_in._itemClass or "tree"
    put_in._itemTag = put_in._itemTag or PARSER.ROOT
    put_in._itemLine = put_in._itemLine or PARSER.TREEFIRSTLINE
    local put_inParams = CopyItemParams(put_in)

    if not put_inParams["_itemClass"]=="tree" then
        LOG("[E] Module XMLParser.lua === Invalid item class")
        error("XMLParser: Invalid item class")
    end

    local fast_content, content, firstLine, lastLine = CheckXMLParserFileForTree(put_inParams)
    if not fast_content then
        return nil
    end

    if not CheckItemClass(put_inParams, treeParams) then
        return nil
    end

    -- if (string.find(fast_content, "<"..tostring(treeParams["_itemTag"]).."(\n*)")) or (string.find(fast_content, "</"..tostring(treeParams["_itemTag"])..">")) then
    --     parserLOG("[E] Module XMLParser.lua === Tree with name \""..tostring(treeParams["_itemTag"]).."\" in '"..PARSER.PATH.."' already exists")
    --     parserPRINT("XMLParser: Tree with name \""..tostring(treeParams["_itemTag"]).."\" in '"..PARSER.PATH.."' already exists")
    --     return nil
    -- end
    fast_content = nil

    firstLine = put_inParams["_itemLine"] or firstLine

    local savedTabs = ""
    local _, _, savedTabss = string.find(content[firstLine], "(\t*)")
    if savedTabss then
        savedTabs = savedTabss
    end

    if not string.find(content[firstLine], ">") then
        repeat
            firstLine=firstLine+1
        until string.find(content[firstLine], ">")
    end

    firstLine = firstLine + 1

    local curLine = firstLine
    local genTree_upTag = savedTabs.."\t<"..tostring(treeParams["_itemTag"])
    -- if PARSER.ENTERS then
    --     if (string.find(content[firstLine-1], "</[^>]>")) or (not string.find(content[firstLine-1], '"%s*>')) or (string.find(content[firstLine], '<[^>]>?')) then
    --         genTree_upTag = "\n"..genTree_upTag
    --     end
    -- end
    table.insert(content, firstLine, genTree_upTag)

    local strSpaces = ""
    if PARSER.SPACES then
        strSpaces = " "
    end

    local ordered_keys = includeKeysForSort or PARSER.KEYS_PriorityGradient

    for i, key in ipairs(ordered_keys) do
        if treeParams[key] then
            if (key and key~="_itemTag" and key~="_itemClass") then
                local genTree_paramTag = savedTabs.."\t\t"..key..''..strSpaces..'='..strSpaces..'"'..treeParams[key]..'"'
                curLine=curLine+1
                table.insert(content, curLine, genTree_paramTag)
                treeParams[key] = nil
            end
        end
    end
    for key, value in pairs(treeParams) do
        if not ____table_contains(ordered_keys, key) then
            if (key and key~="_itemTag" and key~="_itemClass") and value then
                local genTree_paramTag = savedTabs.."\t\t"..key..''..strSpaces..'='..strSpaces..'"'..value..'"'
                curLine=curLine+1
                table.insert(content, curLine, genTree_paramTag)
                treeParams[key] = nil
            end
        end
    end
    content[curLine] = content[curLine]..">"

    curLine = curLine + 1

    local genTree_downTag = savedTabs.."\t</"..tostring(treeParams["_itemTag"])..">"
    
    if PARSER.ENTERS then
        if string.find(content[curLine], "<[^/>]>?") then
            genTree_downTag = genTree_downTag.."\n"
        end
    end

    table.insert(content, curLine, genTree_downTag)

    --LOG("addtree "..tostring(treeParams["_itemTag"]))
    --LOG("\n".._TableToString(content))
    --WriteXMLParserFileForTable(content)
    CollectContentTable(content)

    return true
end



--g_XMLParser:removeTree({_itemClass = "tree", _itemTag = "ExampleTree2"})
function XMLParser:removeTree(treeParams, startLine)
    parserLOG(":::: global method XMLParser:removeTree ::::")
    -- local treeParams = {
    --     _itemTag = "Repository",
    --     Name = "Endings"
    -- }
    local treeName = treeParams["_itemTag"] or PARSER.ROOT
    if treeName==(PARSER.ROOT or string.lower(PARSER.ROOT)) then
        LOG("[E] Module XMLParser.lua === Tree with name \""..tostring(PARSER.ROOT).."\" in "..PARSER.PATH.." cannot be deleted")
        error("XMLParser: Tree with name \""..tostring(PARSER.ROOT).."\" in "..PARSER.PATH.." cannot be deleted")
        return nil
    end
    
    local fast_content, content, firstLine, lastLine = CheckXMLParserFileForTree(treeParams)
    if not fast_content then
        return nil
    end
    fast_content = nil
    local firstLine = startLine or firstLine

    while true do
        if not content[firstLine] then
            break
        end
        if string.find(content[firstLine], "</"..treeName..">") then
            table.remove(content, firstLine)
            break
        end
        table.remove(content, firstLine)
    end

    firstLine = firstLine - 1
    while string.find(content[firstLine], "%s*") and not string.find(content[firstLine], ">") do
        table.remove(content, firstLine)
        firstLine = firstLine - 1
    end
    firstLine = firstLine + 1
    while string.find(content[firstLine], "%s*") and not string.find(content[firstLine], "<") do
        table.remove(content, firstLine)
    end

    local _, name = GetItemKey(treeParams, PARSER.KEYS_SearchingGradient)
    parserLOG("[I] Module XMLParser.lua === Tree <"..treeParams["_itemTag"].."> with value \""..tostring(name).."\" in '"..PARSER.PATH.."' deleted succesfully")
    parserPRINT("Tree <"..treeParams["_itemTag"].."> with value \""..tostring(name).."\" in '"..PARSER.PATH.."' deleted succesfully")

    --WriteXMLParserFileForTable(content)
    CollectContentTable(content)
    return true
end



--g_XMLParser:getTree("TreeExample")
function XMLParser:getTree(treeParams, put_in)
    parserLOG(":::: global method XMLParser:getTree ::::")
    local treeParams = treeParams or PARSER.treeExample
    local put_in = put_in or PARSER.ROOT

    local treeName = treeParams["_itemTag"] or PARSER.ROOT
    local _, treeObjName = GetItemKey(treeParams, PARSER.KEYS_SearchingGradient)
    
    --debug
    -- if treeParams._itemTag=="Special" then
    --     PARSER.LOG = true
    -- end

    local folder, _, folder_firstLine, folder_lastLine = CheckXMLParserFileForTree(put_in, true)
    if not folder then
        parserLOG("[E] Module XMLParser.lua === Parent tree with name \""..put_in.."\" in '"..PARSER.PATH.."' does not exist")
        parserPRINT("Parent tree with name \""..put_in.."\" in '"..PARSER.PATH.."' does not exist")
        return nil
    end

    local fast_content, content, firstLine, lastLine = CheckXMLParserFileForTree(treeParams)
    if not fast_content then
        return nil
    end
    if content then
        if not content[firstLine] then
            return nil
        end
    else
        return nil
    end
    fast_content = nil

    firstLine = treeParams["_itemLine"] or firstLine

    parserLOG("TRY GET<<<\n".._TableToString(treeParams))

    parserLOG("dsa "..content[firstLine])
    if ((string.find(content[firstLine], "</"..treeName..">")) or (string.find(content[firstLine], "<"..treeName))==nil) then
        firstLine = firstLine - 1
    end
    while content[firstLine]==nil do
        firstLine=firstLine+1
    end
    -- parserLOG("das "..content[firstLine])
    -- parserLOG("folder "..content[folder_firstLine])

    local findObjectPattern = '%s*<([^!>%s%/]+)>?[/%s]?'
    local findParamPattern = '%s+([^<\t%s]*)%s*=+%s*"([^"]*)"'

    local startTabs = ""
    local _,_, tabss = string.find(content[firstLine], "(\t*)<")
    if tabss then startTabs = tabss end

    -- if firstLine<folder_firstLine then
    --     firstLine = folder_firstLine
    -- end

    local z = folder_firstLine
    parserLOG("__start tree   :: "..firstLine)
    parserLOG("__start folder :: "..folder_firstLine)
    parserLOG("__enddd tree   :: "..lastLine)
    parserLOG("__enddd folder :: "..folder_lastLine)
    repeat
        local _, _, TreeObj_Name, TreeObj_Value = string.find(content[z], findParamPattern)
        local key, value = GetItemKey(treeParams, PARSER.KEYS_SearchingGradient)
        if (TreeObj_Name == key) and (TreeObj_Value==tostring(treeObjName)) then
            parserLOG("____stop line of tree <"..treeName.."> by name {"..tostring(treeObjName).."}")
            parserLOG("____line of tree name param:: "..z)
            break
        end
        z=z+1
    until ((z==folder_lastLine) or (string.find(content[z-1], "</"..tostring(treeObjName)..">")))

    

    local treeData = {}
    treeData[1] = {}
    treeData[2] = {}
    treeData[3] = {}
    local curLine = firstLine
    local lastStringParam = 0

    treeData[1]["_itemClass"] = "tree"
    treeData[1]["_itemParent"] = put_in
    treeData[1]["_itemLine"] = curLine
    treeData[1]["_itemLineForItems"] = z
    treeData[1]["_itemTag"] = treeName

    -- parserLOG(content[curLine-1])
    -- parserLOG(content[curLine])
    -- parserLOG(content[curLine+1])

    parserLOG("<<<<<<<< "..content[curLine])
    parserLOG("+ Tree: "..tostring(treeData[1]["_itemTag"]))
    parserLOG("\tParent         -> "..tostring(treeData[1]["_itemParent"]))
    parserLOG("\tLine           -> "..tostring(treeData[1]["_itemLine"]))
    parserLOG("\tLineForItems   -> "..tostring(treeData[1]["_itemLineForItems"]))
    local gotAnyValueInTREETAG = string.find(content[curLine], findParamPattern)
    if gotAnyValueInTREETAG then
        parserLOG("gotAnyValueInTREETAG "..content[curLine])
        local itemFirstLineParams = SliceParamsForCommentLines(content[curLine])
        --parserLOG("<"..treeName..">")
        parserLOG(content[curLine])
        for i, line in ipairs(itemFirstLineParams) do
            --parserLOG("{"..line.."}")
            local _, _, getStrParam, getStrValue = string.find(line, findParamPattern)
            if getStrParam and getStrValue then
                parserLOG("\t-> {"..getStrParam.."} {"..getStrValue.."}")

                treeData[1][tostring(getStrParam)] = getStrValue
                lastStringParam = tostring(getStrParam)
            end
        end
    else
        parserLOG("not gotAnyValueInTREETAG "..content[curLine])
        repeat
            parserLOG("getStrParam line "..content[curLine])
            local _, _, getStrParam, getStrValue = string.find(content[curLine], findParamPattern)
            if getStrParam and getStrValue then
                parserLOG("\t-> {"..getStrParam.."} {"..getStrValue.."}")

                treeData[1][tostring(getStrParam)] = getStrValue
                lastStringParam = tostring(getStrParam)
            end
            curLine=curLine+1
            if string.find(content[curLine], startTabs.."</"..treeName..">") then
                treeData[2] = nil
                treeData[3] = nil

                parserLOG("[E] Module XMLParser.lua === Tree \""..treeName.."\" in '"..PARSER.PATH.."' is empty")
                parserPRINT("Tree \""..treeName.."\" in '"..PARSER.PATH.."' is empty")

                return treeData, content, firstLine, lastLine
            end
        until string.find(content[curLine-1], ">")
    end

    local item = 0
    local dropMainChildsRepeat = false
    repeat
        if content[curLine]==content[firstLine] then
            curLine = curLine + 1
        end
        if (content[curLine] == startTabs.."</"..treeName..">") then break end
        local _, _, getStrObject = string.find(content[curLine], startTabs.."\t"..findObjectPattern)
        if getStrObject then
            local ___objectIndexLineNumber = curLine
            item=item+1
            treeData[3][item] = {}

            local itemTabs = ""
            local _,_, tabss = string.find(content[curLine], "(\t*)<")
            if tabss then itemTabs = tabss end

            --class
            local getItemClass = XMLParser:getItemClass(content, curLine, getStrObject)
            
            --item
            treeData[2][item] = {}
            treeData[2][item]["_itemTag"] = getStrObject
            treeData[2][item]["_itemLine"] = ___objectIndexLineNumber
            treeData[2][item]["_itemClass"] = getItemClass
            treeData[2][item]["_itemParent"] = treeName
            treeData[2][item]["_itemProperties"] = {}
            parserLOG("+ Item: "..treeData[2][item]["_itemTag"])

            local scanChilds = true
            
            local _, _, getStrParam, getStrValue = string.find(content[curLine], findParamPattern)
            if getStrParam and getStrValue then
                local itemFirstLineParams = SliceParamsForCommentLines(content[curLine])
                --parserLOG(content[curLine])
                for i, line in ipairs(itemFirstLineParams) do
                    local _, _, getStrParam, getStrValue = string.find(line, findParamPattern)
                    if getStrParam and getStrValue then
                        parserLOG("\t-> {"..getStrParam.."} {"..getStrValue.."}")

                        treeData[2][item]["_itemProperties"][tostring(getStrParam)] = getStrValue
                    end
                end
                if string.find(content[curLine], itemTabs.."<"..getStrObject..">?[^<]*</"..getStrObject..">") then
                    scanChilds = false
                end
                curLine=curLine+1
                if string.find(content[curLine], "[^%s+]+</"..getStrObject..">") and not string.find(content[curLine], findObjectPattern.."%s*</"..getStrObject..">") then
                    scanChilds = false
                end
            else
                repeat
                    curLine=curLine+1
                    local _, _, getStrParam, getStrValue = string.find(content[curLine], findParamPattern)
                    if getStrParam and getStrValue then
                        parserLOG("\t-> {"..getStrParam.."} {"..getStrValue.."}")

                        treeData[2][item]["_itemProperties"][tostring(getStrParam)] = getStrValue
                    end
                until string.find(content[curLine-1], ">")
                if string.find(content[curLine-1], "[^<]*</"..getStrObject..">") then
                    scanChilds = false
                end
            end

            if not content[curLine] then
                break
            end

            --childs
            if getItemClass=="object" then
                parserLOG("========================= skipGetChilds")
            elseif scanChilds then
                parserLOG("========================= tryGetChilds")
                local child = 1
                treeData[3][item]["_itemChilds"] = {}
                repeat
                    if not (content[curLine] == itemTabs.."</"..getStrObject..">") and not string.find(content[curLine-1], "[^<]+</"..getStrObject..">") and not string.find(content[curLine], itemTabs.."[^<]+</"..getStrObject..">") then
                        --parserLOG("skip "..content[curLine])
                        if not string.find(content[curLine], itemTabs..""..findObjectPattern) then
                            curLine=curLine+1
                        end
                    end
                    
                    if not content[curLine] then
                        break
                    end
                    if (content[curLine] == itemTabs.."</"..getStrObject..">") or string.find(content[curLine], itemTabs.."[^<]+</"..getStrObject..">") or (content[curLine] == startTabs.."</"..treeName..">") then
                        --parserLOG("breakkkk "..content[curLine])
                        break
                    end
                    local _, _, ifAgainTree = string.find(content[curLine], itemTabs..""..findObjectPattern)
                    if ifAgainTree then
                        --parserLOG("hook first child "..content[curLine])
                        while (content[curLine] ~= itemTabs.."</"..getStrObject..">") do
                            if not content[curLine] then break end
                            local _, _, ifAgainTree_ = string.find(content[curLine], itemTabs..""..findObjectPattern)
                            if ifAgainTree_ then
                                ifAgainTree = ifAgainTree_
                                local itemChild, intLine = XMLParser:getItemFromLine(content, curLine, getStrObject, itemTabs)
                                curLine = intLine
                                treeData[3][item]["_itemParent"] = getStrObject
                                treeData[3][item]["_itemChilds"][child] = itemChild
                                child=child+1
                                    parserLOG("[I] Module XMLParser.lua === Tree with name \""..treeName.."\" in '"..PARSER.PATH.."' has item <"..getStrObject.."> with childs by first tag \""..ifAgainTree.."\"")
                                    parserPRINT("Tree with name \""..treeName.."\" in "..PARSER.PATH.." has item <"..getStrObject.."> with childs by first tag \""..ifAgainTree.."\"")    
                            end
                            if (content[curLine] == itemTabs.."</"..ifAgainTree..">") or (content[curLine] == itemTabs.."</"..getStrObject..">") or (content[curLine] == startTabs.."</"..treeName..">") then
                                --dropMainChildsRepeat = true
                                break
                            end
                            curLine=curLine+1
                        end
                        break
                    -- else
                    --     local _, _, getStrParam, getStrValue = string.find(content[curLine], findParamPattern)
                    --     if getStrParam and getStrValue then
                    --         parserLOG("\t| {"..getStrParam.."} {"..getStrValue.."}")

                    --         treeData[2][item]["_itemProperties"][tostring(getStrParam)] = getStrValue
                    --     end
                    end
                until (content[curLine] == itemTabs.."</"..getStrObject..">") or (content[curLine] == startTabs.."</"..treeName..">")
            end
            if treeData[3][item]["_itemChilds"] then
                if not treeData[3][item]["_itemChilds"][1] then
                    treeData[3][item]["_itemChilds"] = nil
                end
            end
        end
        if not content[curLine+1] then
            break
        end
        if content[curLine] == startTabs.."</"..treeName..">" or string.find(content[curLine], "[^%s+]+</"..treeName..">") then
            break
        end
        if not string.find(content[curLine], startTabs.."\t"..findObjectPattern) and (content[curLine] ~= startTabs.."</"..treeName..">") then
            curLine = curLine + 1
        end
    until content[curLine] == startTabs.."</"..treeName..">"

    local treeParams = treeData[1][lastStringParam]
    if not treeParams then 
        parserLOG("[I] Module XMLParser.lua === Tree with name \""..treeName.."\" in '"..PARSER.PATH.."' has no parameters")
        parserPRINT("Tree with name \""..treeName.."\" in "..PARSER.PATH.." has no parameters")
        --treeData[1] = nil
    end
    local treeObjects = treeData[2][1]
    if not treeObjects then 
        parserLOG("[I] Module XMLParser.lua === Tree with name \""..treeName.."\" in '"..PARSER.PATH.."' has no items")
        parserPRINT("Tree with name \""..treeName.."\" in '"..PARSER.PATH.."' has no items")
        treeData[2] = nil
        treeData[3] = nil
    end

    parserLOG("\n".._TableToString(treeData))
    
    return treeData, content, firstLine, lastLine
end


function XMLParser:getItemFromLine(content, intLine, parentName, parentTabs)
    parserLOG(":::: global method XMLParser:getItemFromLine ::::")
    local item = {}
    local curLine = intLine
    local parentTabs = parentTabs or ""
    item["_itemParent"] = parentName
    item["_itemLine"] = curLine
    
    local findObjectPattern = '%s*<([^!>%s%/]+)>?[/%s]?'
    local findParamPattern = '%s+([^<\t%s]*)%s*=+%s*"([^"]*)"';

    _,_, item["_itemTag"] = string.find(content[curLine], findObjectPattern)
    item["_itemClass"] = XMLParser:getItemClass(content, curLine, item["_itemTag"])
    
    item["_itemProperties"] = {}
    
    local startTabs = ""
    local _,_, tabss = string.find(content[curLine], "(\t*)<")
    if tabss then startTabs = tabss end

    parserLOG("+ Child: "..item["_itemTag"])
    local gotAnyValueInTREETAG = string.find(content[curLine], findParamPattern)
    if gotAnyValueInTREETAG then
        --parserLOG("gotAnyValueInTREETAG "..content[curLine])
        local itemFirstLineParams = SliceParamsForCommentLines(content[curLine])
        --parserLOG(content[curLine])
        for i, line in ipairs(itemFirstLineParams) do
            --parserLOG("{"..line.."}")
            local _, _, getStrParam, getStrValue = string.find(line, findParamPattern)
            if getStrParam and getStrValue then
                parserLOG("\t-> {"..getStrParam.."} {"..getStrValue.."}")

                item["_itemProperties"][tostring(getStrParam)] = getStrValue
            end
        end
        curLine=curLine+1
    else
        --parserLOG("not gotAnyValueInTREETAG "..content[curLine])
        repeat
            local _, _, getStrParam, getStrValue = string.find(content[curLine], findParamPattern)
            if getStrParam and getStrValue then
                parserLOG("\t-> {"..getStrParam.."} {"..getStrValue.."}")

                item["_itemProperties"][tostring(getStrParam)] = getStrValue
            end
            curLine=curLine+1
            if item["_itemClass"]=="tree" then
                if string.find(content[curLine], startTabs.."</"..item["_itemTag"]..">") or string.find(content[curLine], parentTabs.."</"..parentName..">") then
                    return item, curLine
                end
            else
                if string.find(content[curLine-1], "/>") or string.find(content[curLine], parentTabs.."</"..parentName..">") then
                    return item, curLine
                end
            end
        until string.find(content[curLine-1], ">")
    end

    if item["_itemClass"]=="tree" then
        item["_itemChilds"] = {}
        local child = 1
        while content[curLine]~=startTabs.."</"..item["_itemTag"]..">" and content[curLine]~=parentTabs.."</"..parentName..">" and not string.find(content[curLine], startTabs.."[^<]+</"..item["_itemTag"]..">") do
            -- if content[curLine-1] then
            --     if string.find(content[curLine-1], startTabs.."</"..item["_itemTag"]..">") then
            --         break
            --     end
            -- end
            if string.find(content[curLine], findObjectPattern) then
                local curLine_
                item["_itemChilds"][child], curLine_ = XMLParser:getItemFromLine(content, curLine, item["_itemTag"], startTabs)
                child=child+1
                curLine = curLine_
            else
                curLine=curLine+1
            end
            if not content[curLine] then
                break
            end
        end
    end

    return item, curLine
end



function XMLParser:QuickGet(stringPATH, stringAttrName)
    parserLOG(":::: global method XMLParser:QuickGet ::::")
    local value
	local f = io.open(stringPATH or "data\\config.cfg", "r")
	if f then
		local data = f:read("*all")
		f:close()
		_,_, value = string.find(data, stringAttrName..'%s*=%s*"([^"]*)"')
        data = nil
	end
	return value
end

function XMLParser:QuickSet(stringPATH, stringAttrName, stringAttrValue)
    parserLOG(":::: global method XMLParser:QuickSet ::::")
    local doit
	local f = io.open(stringPATH or "data\\config.cfg", "r")
	if f then
		local data = f:read("*all")
        f:close()
        local start, finish = string.find(data, stringAttrName..'%s*=%s*"[^"]*"')
        if start then
            data = string.sub(data, 1, start-1) .. stringAttrName..'="'..stringAttrValue..'"' .. string.sub(data, finish+1)
            f = io.open(stringPATH or "data\\config.cfg", "w")
            f:write(data)
            f:close()
            doit = true
        end
        data = nil
	end
	return doit
end


function XMLParser:QuickParseLine(stringPATH, stringLinePattern)
    parserLOG(":::: global method XMLParser:QuickParseLine ::::")
    local value
	local f = io.open(stringPATH or "data\\config.cfg", "r")
	if f then
		for line in f:lines() do
			_,_, value = string.find(line, stringLinePattern)
			if value then
                value = string.gsub(value, "\\", "\\\\")
                value = string.gsub(value, "/", "\\\\")
				break
			end
		end
		f:close()
	end
	return value
end



function XMLParser:ReadBinary(stringPATH)
    parserLOG(":::: global method XMLParser:ReadBinary ::::")
    local path = stringPATH or "input_di8.dll" --"hta.exe"
	
	local f = io.open(path, "rb")
	if not f then
		return nil
	end
	local data = f:read("*all")
	f:close()

	local slen = string.len(data)
	local kilo = slen / 1024
	local mega = kilo / 1024

	parserLOG(path)
	parserLOG("File size:", slen, "B")
	parserLOG('\t', kilo, "KB")
	parserLOG('\t', mega, "MB")

	local interpreters = {
		AsHex = function()
            return (string.sub(string.gsub(string.gsub(data, ".", function(c)
				local hex = string.byte(c)
				local high = math.floor(hex / 16)  --старший полубайт
				local low = math.mod(hex, 16)      --младший полубайт
				
				--преобразуем байт в символы цифр и букв: 48 для цифр (0-9), 55 для букв (A-F)
				local highChar = (high < 10) and string.char(high + 48) or string.char(high + 55)
				local lowChar = (low < 10) and string.char(low + 48) or string.char(low + 55)
				return highChar .. lowChar
			end), "(..)", "%1 "), 1, -2))
        end,
		AsASCII = function()
            return (string.gsub(data, ".", function(c)
				local byte = string.byte(c)
				if byte >= 32 and byte <= 126 then
					return c
				else
					return "."
				end
			end))
        end
	}

	local metatable = setmetatable({}, {
		__call = function()
			return slen, kilo, mega
		end,
		__index = function(_, key)
			local interpreter = interpreters[key]
			if interpreter then
				return interpreter()
			else
				return slen, kilo, mega
			end
		end
	})

	return metatable
end



function XMLParser:openQueue(stringPATH)
    parserLOG(":::: global method XMLParser:openQueue ::::")
    local path = stringPATH or ""
    local file = io.open(path, "r+")
    local content = {}
	if file then
		local i = 1
		for line in file:lines() do
			content[i] = line
			i=i+1
		end
		PARSER.OPENEDFILEDESCRYPTOR = file
        PARSER.CACHEDFILEDATA = content
        PARSER.PATH = stringPATH
        return content
    end
    return nil
end

function XMLParser:closeQueue(content, file)
    parserLOG(":::: global method XMLParser:closeQueue ::::")
    local content = content or PARSER.CACHEDFILEDATA or PARSER.FILEDATA
    local file = file or PARSER.OPENEDFILEDESCRYPTOR
    if not is_file_open(file) then
        LOG("[E] Module XMLParser.lua === Queue for file '"..tostring(file).."' already closed!")
        println("[E] Module XMLParser.lua === Queue for file '"..tostring(file).."' already closed!")
        return nil
    end
    if not content then
        content = XMLParser:openQueue(PARSER.PATH)
        LOG("[E] Module XMLParser.lua === Script was triggered in an emergency! '"..tostring(PARSER.PATH).."'")
        println("[E] Module XMLParser.lua === Script was triggered in an emergency! '"..tostring(PARSER.PATH).."'")
    end
    return WriteXMLParserFileForTable(content)
end



function XMLParser:GetItemFromFile(stringFindExample, stringItemTagName, stringItemRepositoryName)
	parserLOG(":::: global method XMLParser:GetItemFromFile ::::")
    --stringFindExample = 'Name%s*=%s*"Player1"'
	local tagName = stringItemTagName or "Object"
	local parentName = stringItemRepositoryName or "DynamicScene"

	local content = PARSER.CACHEDFILEDATA or PARSER.FILEDATA or {}
	
    local gde_item_line = 1
    local parentTabs = ""
    for i, line in ipairs(content) do
        if string.find(line, stringFindExample) then
            gde_item_line = i
            while string.find(content[gde_item_line], "<"..tagName)==nil do
                gde_item_line=gde_item_line-1
                if not content[gde_item_line] then
                    break
                end
            end
            _,_, parentTabs = string.find(content[gde_item_line], "(\t*)")
            parentTabs = string.gsub(parentTabs, "\t", "", 1)
            break
        end
    end

	local item = XMLParser:getItemFromLine(content, gde_item_line, parentName, parentTabs)

	return item, content
end


function XMLParser:RemoveItemFromFile(stringFindExample, stringItemTagName, stringItemRepositoryName)
	parserLOG(":::: global method XMLParser:RemoveItemFromFile ::::")
    local do_it = false
    --stringFindExample = 'Name%s*=%s*"Player1"'
	local tagName = stringItemTagName or "Object"
	local parentName = stringItemRepositoryName or "DynamicScene"

    local content = PARSER.CACHEDFILEDATA or PARSER.FILEDATA or {}

    local gde_item_line = 1
    local parentTabs = ""
    for i, line in ipairs(content) do
        if string.find(line, stringFindExample) then
            gde_item_line = i
            while string.find(content[gde_item_line], "<"..tagName)==nil do
                gde_item_line=gde_item_line-1
                if not content[gde_item_line] then
                    break
                end
            end
            _,_, parentTabs = string.find(content[gde_item_line], "(\t*)")
            parentTabs = string.gsub(parentTabs, "\t", "", 1)
            break
        end
    end

    local item = XMLParser:getItemFromLine(content, gde_item_line, parentName, parentTabs)
    if item then
        local item_line = tonumber(item._itemLine)
        if item_line and item_line>1 then
            local item_class = item._itemClass
            if item_line and item_class then
                local end_fnd = "/>"
                if item_class~="object" then
                    end_fnd = "</"..stringItemTagName..">"
                end
                while content[item_line] do
                    if string.find(content[item_line], end_fnd) then
                        content[item_line] = string.gsub(content[item_line], '[^<]*'..end_fnd, '')
                        do_it = true
                        break
                    end
                    table.remove(content, item_line)
                end
                while content[item_line] do
                    if string.find(content[item_line], '[^%s\t]+') then
                        break
                    else
                        table.remove(content, item_line)
                    end
                end
                CollectContentTable(content)
            end
        end
    end

	return do_it, item, content
end


function XMLParser:SetItemValueInFile(stringFindExample, stringItemTagName, stringItemRepositoryName, stringAttributeName, stringPattern, stringAttributeValue)
    parserLOG(":::: global method XMLParser:SetItemValueInFile ::::")
    local do_it = false
    local item, content = XMLParser:GetItemFromFile(stringFindExample, stringItemTagName, stringItemRepositoryName)
    local itemLine = tonumber(item._itemLine)
    if itemLine then
        if 1>=itemLine then
            return do_it
        end
        local valueLine = itemLine
        --листаем вниз
        repeat
            valueLine=valueLine+1
            if string.find(content[valueLine], stringAttributeName..'%s*=%s*"') then
                break
            end
        until string.find(content[valueLine], '/>')
        --если уперлись вниз, листаем вверх
        if string.find(content[valueLine], '/>') and not string.find(content[valueLine], stringAttributeName..'%s*=%s*"') then
            repeat
                valueLine=valueLine-1
                if string.find(content[valueLine], stringAttributeName..'%s*=%s*"') then
                    break
                end
            until string.find(content[valueLine], '<'..stringItemTagName)
        end

        local _,_, item_value = string.find(content[valueLine], stringAttributeName..'%s*=%s*"([^"]*)"')
        if item_value then
            local pattern = stringPattern or item_value
            local value = stringAttributeValue or item_value
            item_value = string.gsub(item_value, pattern, value)

            content[valueLine] = string.gsub(content[valueLine], stringAttributeName..'(%s*)=(%s*)"[^"]*"', stringAttributeName..'%1=%2"'..item_value..'"')

            do_it = true

            CollectContentTable(content)
        end
    end

    return do_it
end


function XMLParser:ConvertPropertiesIn(stringInputPATH, stringOutputPATH)
	local outputPATH = stringOutputPATH or "func_ConvertPropertiesIn.xml"
	local inputRoot = ""
	if string.find(stringInputPATH, "dynamicscene.xml") then
		inputRoot = "DynamicScene"
	elseif string.find(stringInputPATH, "world.xml") then
		inputRoot = "World"
	end

	if inputRoot~="" then
		local inputFile = io.open(stringInputPATH, "r")
		if inputFile then
			local outputFile = io.open(outputPATH, "w")
			if outputFile then
				for line in inputFile:lines() do
					local str = line
					str = string.gsub(str, 'Pos(%s*)=(%s*)"(%S+)%s+(%S+)%s+(%S+)"', 'Pos%1=%2"CVector(%3, %4, %5)"')
					str = string.gsub(str, 'Rot(%s*)=(%s*)"(%S+)%s+(%S+)%s+(%S+)%s+(%S+)"', 'Rot%1=%2"Quaternion(%3, %4, %5, %6)"')
					str = string.gsub(str, 'org(%s*)=(%s*)"(%S+)%s+(%S+)%s+(%S+)"', 'org%1=%2"CVector(%3, %4, %5)"')
					str = string.gsub(str, 'rot(%s*)=(%s*)"(%S+)%s+(%S+)%s+(%S+)%s+(%S+)"', 'rot%1=%2"Quaternion(%3, %4, %5, %6)"')
					outputFile:write(str.."\n")
				end
				outputFile:close()
			end
			inputFile:close()
		end

		local success = XMLParser:init(outputPATH, inputRoot, nil, false)
		if success then
			if XMLParser:Tree({inputRoot}):init() then
				XMLParser:Tree():AddParam("CopiedFrom", stringInputPATH)
			end
			XMLParser:save()
		end
	end
end


function XMLParser:GetItemCustomKey(itemParams, tableKeys)
    parserLOG(":::: global method XMLParser:GetItemCustomKey ::::")
    local tableKeys = tableKeys or PARSER.KEYS_SearchingGradient
    return GetItemKey(itemParams, tableKeys)
end


function XMLParser:getItemClass(content, curLine, getStrObject)
    parserLOG(":::: global method XMLParser:getItemClass ::::")
    local findObjectPattern = '%s*<([^!>%s%/]+)>?[/%s]?'
    local findParamPattern = '%s+([^<\t%s]*)%s*=+%s*"([^"]*)"'

    local getItemClass = "item"
    local lineForScan = curLine
    local openTagLine = content[lineForScan]
    local closeTagLine = ""
    parserLOG("sssss -> "..content[lineForScan])
    if not string.find(openTagLine, "/>") and not string.find(openTagLine, ">") then
        repeat
            closeTagLine = content[lineForScan]
            lineForScan=lineForScan+1
            parserLOG("fnd close tag -> "..closeTagLine)

            if string.find(closeTagLine, "[^/]>") then
                getItemClass = "tree"
                break
            end
            if (not string.find(closeTagLine, "/>") and (string.find(closeTagLine, findObjectPattern))) then
                local _, _, newObj = string.find(closeTagLine, findObjectPattern)
                while ((string.find(closeTagLine, "/>") or (string.find(closeTagLine, "</"..newObj..">")))) do
                    closeTagLine = content[lineForScan]
                    lineForScan=lineForScan+1
                    parserLOG("fnd objec tag -> "..closeTagLine)
                end 
            end
        until ((string.find(content[lineForScan-1], "/>") and not (string.find(content[lineForScan-1], findObjectPattern))) or string.find(content[lineForScan-1], "</"..getStrObject..">"))
        if (string.find(openTagLine, "<"..getStrObject..">?[/%s]?")) and (string.find(closeTagLine, "</"..getStrObject..">")) then
            getItemClass = "tree"
                parserLOG("$tree")
        elseif (string.find(openTagLine, "<"..getStrObject)) and (string.find(closeTagLine, "/>")) then
            getItemClass = "object"
                parserLOG("$object")
        else
            parserLOG("$tree or kurva")
        end
    else
        if string.find(openTagLine, "/>") then
            getItemClass = "object"
                parserLOG("$object")
        elseif string.find(openTagLine, ">") then
            getItemClass = "tree"
                parserLOG("$tree")
        else
            parserLOG("$kurva")
        end
    end
    parserLOG("$GETITEMCLASS: "..getItemClass)
    return getItemClass
end



--g_XMLParser:addObject(nil, "TreeExample")
function XMLParser:addObject(objectParams, put_in, includeKeysForSort)
    parserLOG(":::: global method XMLParser:addObject ::::")
    put_in._itemClass = put_in._itemClass or "tree"
    put_in._itemTag = put_in._itemTag or PARSER.ROOT
    put_in._itemLine = put_in._itemLine or PARSER.TREEFIRSTLINE
    local put_inParams = CopyItemParams(put_in)

    if not put_inParams["_itemClass"]=="tree" then
        LOG("[E] Module XMLParser.lua === Invalid item class")
        error("XMLParser: Invalid item class")
    end

    local objectParams = objectParams or PARSER.itemExample

    objectParams["_itemTag"] = objectParams["_itemTag"] or "Object"

    if not objectParams["_itemClass"]=="object" then
        LOG("[E] Module XMLParser.lua === Attempt to add item without class 'object' for \""..treeName.."\" in '"..PARSER.PATH.."'")
        error("XMLParser: Attempt to add item without class 'object' for \""..treeName.."\" in '"..PARSER.PATH.."'")
        return nil
    end

    local exists, _, content, firstLine, lastLine = CheckXMLParserFileTreeForItem(put_inParams, objectParams)
    if exists then
        return nil
    end

    firstLine = put_inParams["_itemLine"] or firstLine

    local savedTabs = ""
    local _, _, savedTabss = string.find(content[firstLine], "(\t*)")
    if savedTabss then
        savedTabs = savedTabss
    end

    if not string.find(content[firstLine], ">") then
        repeat
            firstLine=firstLine+1
        until string.find(content[firstLine], ">")
    end

    firstLine = firstLine + 1

    local curLine = firstLine
    local genObject_upTag = savedTabs.."\t<"..tostring(objectParams["_itemTag"])
    -- if PARSER.ENTERS then
    --     if (string.find(content[firstLine-1], "</[^>]>")) or (not string.find(content[firstLine-1], "<[^>]>?")) then
    --         genObject_upTag = "\n"..genObject_upTag
    --     end
    -- end
    table.insert(content, firstLine, genObject_upTag)

    local strSpaces = ""
    if PARSER.SPACES then
        strSpaces = " "
    end
    
    local ordered_keys = includeKeysForSort or PARSER.KEYS_PriorityGradient

    for i, key in ipairs(ordered_keys) do
        if objectParams[key] then
            if (key and key~="_itemTag" and key~="_itemClass") then
                local genObject_paramTag = savedTabs.."\t\t"..key..''..strSpaces..'='..strSpaces..'"'..objectParams[key]..'"'
                curLine=curLine+1
                table.insert(content, curLine, genObject_paramTag)
                objectParams[key] = nil
            end
        end
    end
    for key, value in pairs(objectParams) do
        if not ____table_contains(ordered_keys, key) then
            if (key and key~="_itemTag" and key~="_itemClass") then
                local genObject_paramTag = savedTabs.."\t\t"..key..''..strSpaces..'='..strSpaces..'"'..value..'"'
                curLine=curLine+1
                table.insert(content, curLine, genObject_paramTag)
                objectParams[key] = nil
            end
        end
    end
    content[curLine] = content[curLine].." />"

    if PARSER.ENTERS then
        if string.find(content[curLine+1], "<[^/>]>?") then
            content[curLine] = content[curLine].."\n"
        end
    end

    --LOG("addobject "..tostring(objectParams["_itemTag"]))
    --LOG("\n".._TableToString(content))
    --WriteXMLParserFileForTable(content)
    CollectContentTable(content)

    return true
end


--g_XMLParser:removeObject()
--g_ModStats:removeObject()
function XMLParser:removeObject(treeParams, objectParams)
    parserLOG(":::: global method XMLParser:removeObject ::::")
    -- local treeParams = {
    --     _itemTag = "ModStatsDescription",
    --     --Name = "Achievements"
    -- }
    -- local objectParams = {
    --     _itemTag = "PlayerDeaths",
    --     --Name = "Нужна помощь?"
    -- }

    local objectParams = objectParams or PARSER.itemExample
    local treeName = treeParams["_itemTag"] or PARSER.ROOT

    local KeyForSearch = GetItemKey(objectParams, PARSER.KEYS_SearchingGradient)
    local _, treeee = GetItemKey(treeParams, PARSER.KEYS_SearchingGradient)
    
    local treeData, content, firstLine, lastLine = XMLParser:getTree(treeParams)

    local objLine = nil
    local obj, objj, skoka = 1, 1, 0
    if treeData[2] and treeData[2][obj] then
        while treeData[2][obj]~=nil do
            if (treeData[2][obj]["_itemClass"]=="object") and (treeData[2][obj]["_itemTag"]==objectParams["_itemTag"]) then
                skoka = skoka + 1
                objj = obj
            end
            obj=obj+1
        end
        if skoka>=2 then
            obj = 1
            while treeData[2][obj]~=nil do
                if (treeData[2][obj]["_itemClass"]=="object") and (treeData[2][obj]["_itemTag"]==objectParams["_itemTag"]) and (treeData[2][obj]["_itemProperties"][KeyForSearch]==objectParams[KeyForSearch]) then
                    objLine = treeData[2][obj]["_itemLine"]
                    break
                end
                obj=obj+1
            end
        elseif skoka==1 then
            objLine = treeData[2][objj]["_itemLine"]
        else
            LOG("[E] Module XMLParser.lua === Object <"..objectParams["_itemTag"].."> with value \""..tostring(objectParams[KeyForSearch]).."\" in tree <"..treeName.."> with name \""..tostring(treeee).."\" '"..PARSER.PATH.."' not found")
            error("XMLParser: Object <"..objectParams["_itemTag"].."> with value \""..tostring(objectParams[KeyForSearch]).."\" in tree <"..treeName.."> with name \""..tostring(treeee).."\" '"..PARSER.PATH.."' not found")
            return nil
        end
    end
    
    if objLine then
        while true do
            if not content[objLine] then
                break
            end
            if string.find(content[objLine], "</"..treeName..">") then
                table.remove(content, objLine)
                break
            end
            table.remove(content, objLine)
        end

        objLine = objLine - 1
        while string.find(content[firstLine], "%s*") and not string.find(content[firstLine], ">") do
            table.remove(content, objLine)
            objLine = objLine - 1
        end
        objLine = objLine + 1
        while string.find(content[firstLine], "%s*") and not string.find(content[firstLine], "<") do
            table.remove(content, objLine)
        end

        parserLOG("[I] Module XMLParser.lua === Object <"..objectParams["_itemTag"].."> with value \""..tostring(objectParams[KeyForSearch]).."\" in tree <"..treeName.."> with name \""..tostring(treeee).."\" '"..PARSER.PATH.."' deleted succesfully")
        parserPRINT("Object <"..objectParams["_itemTag"].."> with value \""..tostring(objectParams[KeyForSearch]).."\" in tree <"..treeName.."> with name \""..tostring(treeee).."\" '"..PARSER.PATH.."' deleted succesfully")

        --WriteXMLParserFileForTable(content)
        CollectContentTable(content)
        return true
    end

    parserLOG("[I] Module XMLParser.lua === Object <"..objectParams["_itemTag"].."> with value \""..tostring(objectParams[KeyForSearch]).."\" in tree <"..treeName.."> with name \""..tostring(treeee).."\" '"..PARSER.PATH.."' not found")
    parserPRINT("Object <"..objectParams["_itemTag"].."> with value \""..tostring(objectParams[KeyForSearch]).."\" in tree <"..treeName.."> with name \""..tostring(treeee).."\" '"..PARSER.PATH.."' not found")

    return false
end


function XMLParser:Wrap(objectParams)
    parserLOG(":::: global method XMLParser:Wrap ::::")
    local fast_content = PARSER.TREEDATA
    local content = _CopyTable(PARSER.FILEDATA)
    local firstLine = PARSER.TREEFIRSTLINE
    local lastLine = PARSER.TREELASTLINE
    local itemName = PARSER.TREEDATA[1]["_itemTag"]
    if type(objectParams)=="table" then
        firstLine = objectParams["_itemLine"] or firstLine
        itemName = objectParams["_itemTag"] or PARSER.TREEDATA[1]["_itemTag"]
    end

    if fast_content and content and firstLine and lastLine and itemName then

        if not content[firstLine] then
            parserLOG("[E] Module XMLParser.lua === Couldn't access the updated tree")
            parserPRINT("Couldn't access the updated tree")
            return nil
        end
        if string.find(content[firstLine], ">") then
            parserLOG("[E] Module XMLParser.lua === Invalid structure of item <"..itemName.."> on line '"..firstLine.."'")
            parserPRINT("Invalid structure of item <"..itemName.."> on line '"..firstLine.."'")
            return nil
        end
        while string.find(content[firstLine], "<"..itemName)==nil do
            parserLOG("nenashol")
            firstLine=firstLine-1
        end

        parserLOG("cathced content = {\n".._TableToString(content).."}end")

        --parserLOG(content[firstLine])
        --parserLOG(content[firstLine+1])
        
        local catchTree = content
        local eraseLine = firstLine
        while string.find(catchTree[eraseLine], ">")==nil do
            eraseLine = eraseLine + 1
            if string.find(catchTree[eraseLine], ">") then
                eraseLine = eraseLine + 1
                break
            end
        end

        if firstLine~=eraseLine then
            catchTree[firstLine-1] = catchTree[firstLine-1].."@@@<superMegaTagForUNWRAP>@@@"

            while (catchTree[eraseLine]~=nil) do
                table.remove(catchTree, eraseLine)
            end
            while (catchTree[1]~=nil) and (not (string.find(catchTree[1], "@@@<superMegaTagForUNWRAP>@@@"))) do
                table.remove(catchTree, 1)
            end
            table.remove(catchTree, 1)

            parserLOG("cathced item = {\n".._TableToString(catchTree).."}end")
        else
            catchTree = catchTree[firstLine]
            parserLOG("cathced line = {"..tostring(catchTree).."}end")
        end

        local wrapedItem = PackStringFromTable(catchTree, true)

        if (not wrapedItem) or (not (string.find(wrapedItem, "<"..itemName))) and (not (string.find(wrapedItem, ">"))) then
            LOG("[E] Module XMLParser.lua === Invalid structure of item")
            parserPRINT("Invalid structure of item")
            return nil
        end

        parserLOG("wraped item = {"..tostring(wrapedItem).."}end")

        content = nil
        fast_content = nil

        return wrapedItem
    end
    return nil
end


function XMLParser:Unwrap(objectParams)
    parserLOG(":::: global method XMLParser:Unwrap ::::")
    local fast_content, content, firstLine, lastLine = PARSER.TREEDATA, PARSER.FILEDATA, PARSER.TREEFIRSTLINE, PARSER.TREELASTLINE
    local itemName = PARSER.TREEDATA[1]["_itemTag"]
    if type(objectParams)=="table" then
        firstLine = objectParams["_itemLine"] or firstLine
        itemName = objectParams["_itemTag"] or PARSER.TREEDATA[1]["_itemTag"]
    end

    if fast_content and content and firstLine and lastLine and itemName then

        if not content[firstLine] then
            LOG("[E] Module XMLParser.lua === Couldn't access the updated tree")
            parserPRINT("Couldn't access the updated tree")
            return nil
        end
        if not string.find(content[firstLine], ">") then
            LOG("[E] Module XMLParser.lua === Invalid structure of item <"..itemName.."> on line '"..firstLine.."'")
            parserPRINT("Invalid structure of item <"..itemName.."> on line '"..firstLine.."'")
            return nil
        end
        while string.find(content[firstLine], "<"..itemName)==nil do
            parserLOG("nenashol")
            firstLine=firstLine-1
        end

        parserLOG("cathced content = {\n".._TableToString(content).."}end")

        parserLOG(content[firstLine])
        --parserLOG(content[firstLine])
        --parserLOG(content[firstLine+1])
        
        local catchTree = content
        local eraseLine = firstLine
        while string.find(catchTree[eraseLine-1], ">")==nil do
            if string.find(catchTree[eraseLine], ">") then
                break
            end
            eraseLine = eraseLine + 1
        end

        if firstLine~=eraseLine then
            catchTree[firstLine] = catchTree[firstLine].."@@@<superMegaTagForUNWRAP>@@@"

            while (catchTree[eraseLine]~=nil) do
                table.remove(catchTree, eraseLine)
            end
            while (catchTree[1]~=nil) and (not (string.find(catchTree[1], "@@@<superMegaTagForUNWRAP>@@@"))) do
                table.remove(catchTree, 1)
            end
            table.remove(catchTree, 1)

            parserLOG("cathced item = {\n".._TableToString(catchTree).."}end")
        else
            catchTree = catchTree[firstLine]
            parserLOG("cathced line = {"..tostring(catchTree).."}end")
        end

        local unwrapedItem = PackStringFromTable(catchTree)

        if (not unwrapedItem) or (not string.find(unwrapedItem, "<"..itemName)) then
            LOG("[E] Module XMLParser.lua === Invalid structure of item")
            parserPRINT("Invalid structure of item")
            return nil
        end
        
        unwrapedItem = UnwrapItemForCommentLines(unwrapedItem)

        parserLOG("unwraped item = {\n".._TableToString(unwrapedItem).."}end")

        return unwrapedItem
    end
    return nil
end


function XMLParser:AutoUpdateTree(bool)
    parserLOG(":::: global method XMLParser:AutoUpdateTree ::::")
    if bool then
        PARSER.AUTOUPDATE = true
    else
        PARSER.AUTOUPDATE = false
    end
end


function XMLParser:GetTagAndCustomKeyFromItem(itemParams)
    parserLOG(":::: global method XMLParser:GetTagAndCustomKeyFromItem ::::")
    if not itemParams then itemParams = {} end
    local tag = itemParams["_itemTag"]
    local customKey = GetItemKey(itemParams, PARSER.KEYS_SearchingGradient)
    return {tag, customKey}
end


function XMLParser:GetLineWithContent(line, stringContent)
    parserLOG(":::: global method XMLParser:GetLineWithContent ::::")
    if (not line) and (not stringContent) then
        return nil
    end

    XMLParser:Tree():tryUpdate()

    local strLine 
    if line and stringContent then
        if string.find(PARSER.FILEDATA[line], stringContent) then
            strLine = PARSER.FILEDATA[line]
        end
    elseif stringContent then
        for i, v in ipairs(PARSER.FILEDATA) do
            if string.find(v, stringContent) then
                strLine = PARSER.FILEDATA[i]
                break
            end
        end
    elseif line then
        strLine = PARSER.FILEDATA[line]
    end

    return strLine, line
end


function XMLParser:RemoveLineWithContent(line, stringContent)
    parserLOG(":::: global method XMLParser:RemoveLineWithContent ::::")
    if (not line) and (not stringContent) then
        return nil
    end

    XMLParser:Tree():tryUpdate()

    local strLine 
    if line and stringContent then
        if string.find(PARSER.FILEDATA[line], stringContent) then
            strLine = PARSER.FILEDATA[line]
            if strLine then
                table.remove(PARSER.FILEDATA, line)
            end
        end
    elseif stringContent then
        for i, v in ipairs(PARSER.FILEDATA) do
            if string.find(v, stringContent) then
                strLine = PARSER.FILEDATA[i]
                table.remove(PARSER.FILEDATA, i)
                break
            end
        end
    elseif line then
        strLine = PARSER.FILEDATA[line]
        if strLine then
            table.remove(PARSER.FILEDATA, line)
        end
    end

    if strLine then
        --WriteXMLParserFileForTable(PARSER.FILEDATA)
        CollectContentTable(PARSER.FILEDATA)

        return true, line, strLine
    end
    return false
end


function XMLParser:AddCommentNearItem(comment, objectParams)
    parserLOG(":::: global method XMLParser:AddCommentNearItem ::::")
    local comment = comment or ""
    local objectParams = objectParams or PARSER.itemExample
    if not type(objectParams)=="table" then
        LOG("[E] Module XMLParser.lua === Invalid objectParams data")
        parserPRINT("Invalid objectParams data")
        return nil
    end
    if not type(comment)=="string" then
        LOG("[E] Module XMLParser.lua === Invalid comment type")
        parserPRINT("Invalid comment type")
        return nil
    end

    local KeyForSearch = GetItemKey(objectParams, PARSER.KEYS_SearchingGradient)

    objectParams[1] = objectParams["_itemClass"] or objectParams[1]
    objectParams[2] = objectParams["_itemTag"] or objectParams[2]
    objectParams[3] = objectParams["_customValue"] or KeyForSearch or objectParams[3]
    local stringCustomKeyValue = objectParams[objectParams[3]]

    XMLParser:Tree():tryUpdate()

    local _, idValue = GetItemKey(objectParams, PARSER.KEYS_Id)

    local itemData
    if objectParams[1]=="object" then
        if idValue then objectParams[3] = idValue end
        itemData = XMLParser:Tree():GetObj({objectParams[2], objectParams[3]}, stringCustomKeyValue)
    elseif objectParams[1]=="tree" then
        local treeById = XMLParser:Tree():GetTreeById(idValue)
        local treeByCustomKey = XMLParser:Tree():GetTreeByCustomKey(KeyForSearch, stringCustomKeyValue)
        local treeByName = XMLParser:Tree():GetTreeByName(objectParams[3])
        local treeByTag = XMLParser:Tree():GetTree(objectParams[2])

        treeById = treeById or {}
        treeByCustomKey = treeByCustomKey or {}
        treeByName = treeByName or {}
        treeByTag = treeByTag or {}

        if treeById["_itemLine"] then
            itemData = treeById
        elseif treeByCustomKey["_itemLine"] then
            itemData = treeByCustomKey
        elseif treeByName["_itemLine"]==treeByTag["_itemLine"] then
            itemData = treeByName
        else
            itemData = treeByTag
        end
    end

    if not itemData then
        return nil
    end

    local commentLine 
    if itemData["_object"] then
        commentLine = itemData["_object"]["_itemLine"]
    elseif itemData["_itemLine"] then
        commentLine = itemData["_itemLine"]
    elseif itemData["firstLine"] then
        commentLine = itemData["firstLine"]
    end
    
    if not commentLine then
        LOG("[E] Module XMLParser.lua === Can't find line for comment")
        parserPRINT("Can't find line for comment")
        return nil
    end

    local commentStr = "<!-- "..comment.." -->"

    table.insert(PARSER.FILEDATA, commentLine, commentStr)

    --WriteXMLParserFileForTable(PARSER.FILEDATA)
    CollectContentTable(PARSER.FILEDATA)
    
    return true, commentLine
end



-- ////////////////////// GLOBAL MODULE METHODS //////////////////////////////



--class trigger
--XMLParser:init("data\\maps\\0r5m3\\triggers.xml", "triggers", nil, false)
--local stringTriggerName = "test"
function XMLParser:trigger(stringTriggerName)
    parserLOG(":::: global method XMLParser:trigger ::::")
    --XMLParser:Tree():tryUpdate()

    local triggerBody = ""
    local triggerActive = false
    local triggerEvents = {}

    local event_properties = PARSER.KEYS_TriggerEvent

    local root = XMLParser:Tree({"triggers"}):init()
    local file = XMLParser:Tree().content
    local trigger_exists, triggerItem = XMLParser:Tree():IsTreeExists({"trigger", tostring(stringTriggerName)})
    
    local _itemLine
    if triggerItem then
        _itemLine = tonumber(triggerItem._itemLine) or 1
    else
        _itemLine = 1
    end

    local write_triggers_file = function(content)
            local content = content or file or read_triggers_file()
            CollectContentTable(content)
            return XMLParser:closeQueue(content)
        end
    
    if trigger_exists then
        local active = triggerItem["_itemProperties"].active
        if active=="1" then
            triggerActive = true
        end

        if file and _itemLine then
            if file[_itemLine] then
                local inScript = false
                while file[_itemLine] do
                    if not inScript then
                        if string.find(file[_itemLine], "<event[^>]*/>") then
                            --LOG("{"..file[_itemLine].."}")
                            local event = {}
                            for i, key in ipairs(event_properties) do
                                local _,_, property = string.find(file[_itemLine], key..'%s*=%s*"([^"]*)"')
                                --LOG(key.." "..tostring(property))
                                if property then event[key] = property end
                            end
                            table.insert(triggerEvents, event)
                        end
                    else
                        local retVal = ""
                        if not string.find(file[_itemLine], "</?script>") and not string.find(file[_itemLine], "</?trigger>") then
                            retVal = file[_itemLine]
                            --triggerBody = triggerBody.."\n"..retVal
                            triggerBody = triggerBody..retVal.."; "
                        end
                    end
                    if string.find(file[_itemLine], "<script>") then
                        inScript = true
                    end
                    if string.find(file[_itemLine], "</trigger>") then
                        break
                    end

                    _itemLine = _itemLine + 1
                end
            end
        end

        local parse_triggerScript = function(triggerBody)
            local triggerScript = {}
            triggerBody = triggerBody.."\n"
            local startLine, endLine = 1, 1
            for i = 1, string.len(triggerBody) do
                startLine, endLine = startLine, i
                if string.sub(triggerBody, i, i) == "\n" then
                    local line = string.sub(triggerBody, startLine, endLine)
                    line = string.gsub(line, "\n", "")
                    table.insert(triggerScript, line)
                    startLine = i
                end
            end
            return triggerScript
        end

        local get_script = function()
            local triggerBody = string.gsub(triggerBody, "; ", "\n")
            return parse_triggerScript(triggerBody)
        end

        local read_triggers_file = function()
            local path = PARSER.PATH
            local content = XMLParser:openQueue(path)
            return content
        end

        local delete_triggerScript = function()
            local content = file or read_triggers_file()
            if content then
                local i = _itemLine
                while content[i] do
                    if string.find(content[i], "</script>") then
                        i=i-1
                        while content[i] do
                            if string.find(content[i], "<script>") then
                                while string.find(content[i], "</script>")==nil do
                                    i=i+1
                                end
                                break
                            end
                            table.remove(content, i)
                            i=i-1
                        end
                    end
                    if string.find(content[i], "<script>") then
                        break
                    end
                    i=i-1
                end
                return content, i
            end
            return nil
        end

        local write_triggerScript = function(content, iline, triggerScript)
            local content = content or file or read_triggers_file()
            if content then
                local i = iline or _itemLine
                while content[i] do
                    if string.find(content[i], "<script>") then
                        i=i+1
                        for j, line in ipairs(triggerScript) do
                            table.insert(content, i, line)
                            i=i+1
                        end
                        return content
                    end
                    i=i-1
                end
            end
            return nil
        end

    
        local TRIGGER = {
            Add = function()
                return "idi nahuy etot trigger already exists)))0)"
            end,
            Remove = function()
                local content = file or read_triggers_file()
                local i = _itemLine
                repeat
                    table.remove(content, i)
                    if not content[i] then
                        break
                    end
                    i=i-1
                until string.find(content[i], "</trigger>") or string.find(content[i], "<triggers>")
                return write_triggers_file(content)
            end,
            IsActive = function()
                return triggerActive
            end,
            SetActive = function(_, boolActive)
                local do_it = false
                local content = file or read_triggers_file()
                local i = _itemLine
                while content[i] do
                    if string.find(content[i], "<trigger") and string.find(content[i], 'Name%s*=%s*"'..stringTriggerName..'"') then
                        if boolActive then
                            content[i] = string.gsub(content[i], 'active="[^"]"', 'active="1"')
                        else
                            content[i] = string.gsub(content[i], 'active="[^"]"', 'active="0"')
                        end
                        do_it = true
                        break
                    end
                    i=i-1
                    if string.find(content[i], "</trigger>") then
                        break
                    end
                end
                write_triggers_file(content)
                return do_it
            end,
            GetBody = function()
                triggerBody = string.gsub(triggerBody, "; ", "\n")
                return triggerBody
            end,
            DoScript = function() 
                local call_code = function()
                    triggerBody = string.gsub(triggerBody, ";", "\n")
                    triggerBody = string.gsub(triggerBody, "\t", " ")
                    triggerBody = string.gsub(triggerBody, "trigger:[^%)]*%)", "") --trigger global methods = nil value, please specify the reference to the trigger as an object [local trig = getObj("trigger_name")] in the trigger body.
                    local str = "local f = function() "..triggerBody.." end; return f"
                    local f = dostring(str)
                    if f then 
                        f()
                        return true 
                    end 
                    return false
                end
                local success, err = pcall(call_code)
                return success, err
            end,

            GetAllEvents = function()
                return triggerEvents
            end,
            GetEventById = function(_, EventId)
                for i, event in ipairs(triggerEvents) do
                    local eventid = event.eventid
                    if EventId and eventid then
                        if EventId==eventid then
                            return event
                        end
                    end
                end
                return nil
            end,
            GetEventByKey = function(_, EventKey, EventValue)
                for i, event in ipairs(triggerEvents) do
                    local eventKey = event[EventKey]
                    if eventKey then
                        if EventValue then
                            if EventValue==eventKey then
                                return event
                            end
                        else
                            return event
                        end
                    end
                end
                return nil
            end,
            RemoveEvent = function(_, event)
                local do_it = false
                local eventid = event.eventid
                local content = file or read_triggers_file()
                local i = _itemLine
                while content[i] do
                    if string.find(content[i], "<trigger") then
                        break
                    end
                    if string.find(content[i], "<event") then
                        if string.find(content[i], 'eventid%s*=%s*"'..eventid..'"') then
                            for j, key in ipairs(event_properties) do
                                if key~="eventid" then
                                    local _,_, property = string.find(content[i], key..'%s*=%s*"([^"]*)"')
                                    if event[key] and property then
                                        if event[key]==property then
                                            table.remove(content, i)
                                            do_it = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                    i=i-1
                end
                write_triggers_file(content)
                return do_it
            end,
            AddEvent = function(_, event)
                local do_it = false
                local content = file or read_triggers_file()
                local i = _itemLine
                while content[i] do
                    if string.find(content[i], "<event") or string.find(content[i], "<trigger") then
                        local _,_, tabs = string.find(content[i], "(\t*)")
                        if not tabs then tabs = "" end
                        i=i+1
                        local eventt = tabs..'<event '
                        for key, value in pairs(event) do
                            eventt = eventt..key..'="'..value..'" '
                        end
                        eventt = eventt..'/>'
                        table.insert(content, i, eventt)
                        do_it = true
                        break
                    end
                    i=i-1
                end
                write_triggers_file(content)
                return do_it
            end,

            GetScript = function()
                local triggerScript = get_script()
                --LOG("GetScript\n"..tostring(_TableToString(triggerScript)))
                return triggerScript
            end,
            GetScriptByLine = function(_, intLine)
                local triggerScript = get_script()
                return triggerScript[intLine]
            end,
            GetLineByScriptContent = function(_, stringContent)
                local triggerScript = get_script()
                for i, line in ipairs(triggerScript) do
                    if string.find(line, stringContent) then
                        return i
                    end
                end
                return nil
            end,
            ReplaceScript = function(_, stringNewScript)
                local do_it = false
                local stringNewScript = parse_triggerScript(stringNewScript)
                local content
                if stringNewScript[1] then
                    content, i = delete_triggerScript()
                    content = write_triggerScript(content, i, stringNewScript)
                    do_it = true
                end
                
                write_triggers_file(content)
                return do_it
            end,
            RemoveScript = function()
                delete_triggerScript()
                write_triggers_file(content)
            end,
            RemoveScriptLine = function(_, intLineORstringContent)
                local do_it = false
                local triggerScript = get_script()
                if type(intLineORstringContent)=="number" then
                    if table.remove(triggerScript, intLineORstringContent) then
                        local content, i = delete_triggerScript()
                        content = write_triggerScript(content, i, triggerScript)
                        
                        return write_triggers_file(content)
                    end
                elseif type(intLineORstringContent)=="string" then
                    for i, line in ipairs(triggerScript) do
                        if string.find(line, intLineORstringContent) then
                            if table.remove(triggerScript, i) then
                                local content, i = delete_triggerScript()
                                content = write_triggerScript(content, i, triggerScript)
                                
                                return write_triggers_file(content)
                            end
                        end
                    end
                end
                return nil
            end,
            AddScript = function(_, stringScript, intLine)
                local call_code = function()
                    local triggerScript = get_script()
                    local intLine = intLine or getn(triggerScript) + 1

                    local additional_triggerScript = string.gsub(stringScript, "; ", "\n")
                    additional_triggerScript = parse_triggerScript(additional_triggerScript)

                    local _,_, tabs = string.find(tostring(triggerScript[intLine]), "(\t*)")
                    for i, newLine in ipairs(additional_triggerScript) do
                        if tabs then
                            newLine = tabs..newLine
                        end
                        table.insert(triggerScript, intLine, newLine)
                        intLine=intLine+1
                    end
                    table.remove(triggerScript) --kek

                    local content, i = delete_triggerScript()
                    content = write_triggerScript(content, i, triggerScript)
                    --LOG("AddScript\n"..tostring(_TableToString(triggerScript)))
                    
                    return write_triggers_file(content)
                end
                local success, err = pcall(call_code)
                return success, err
            end
        }

        return TRIGGER
    else
        LOG("[E] Module XMLParser.lua === Can't find trigger '"..tostring(stringTriggerName).."' in file")
        parserPRINT("Can't find trigger '"..tostring(stringTriggerName).."' in file")

        local TRIGGER = {
            Add = function(_, intActive, tableEvents, tableScript)
                local content = file or read_triggers_file()
                local i = getn(content)
                repeat
                    i=i-1
                until string.find(content[i-1], "</trigger>") or string.find(content[i-1], "<triggers>")
                
                local intActive = intActive or 0
                local tableEvents = tableEvents or {'<event timeout="0" eventid="GE_TIME_PERIOD" />'}
                tableEvents = table.concat(tableEvents, "\n\t\t")
                local tableScript = tableScript or {'trigger:Deactivate()'}
                tableScript = table.concat(tableScript, "\n\t\t\t")

                local trigger_item = {
                    '\t<trigger Name="'..stringTriggerName..'" active="'..intActive..'">',
                    '\t\t'..tableEvents,
                    '\t\t<script>',
                    '\t\t\t'..tableScript,
                    '\t\t</script>',
                    '\t</trigger>'
                }

                local trigger = table.concat(trigger_item, "\n")

                table.insert(content, i+1, trigger)

                return write_triggers_file(content)
            end
        }

        return TRIGGER
    end
end



--class tree
--XMLParser:Tree({_itemTag="Repository", Name="Achievements"}):init()
function XMLParser:Tree(treeParams)
    parserLOG(":::: global method XMLParser:Tree ::::")
    local treeParams = treeParams or PARSER.CACHE_TREEPARAMS
    if (not treeParams) or (not type(treeParams)=="table") then 
        treeParams = {_itemTag = PARSER.ROOT}
    elseif (type(treeParams)=="table") and (treeParams["_itemTag"]==nil) then
        treeParams = {
            _itemTag = treeParams[1],
            _customValue = treeParams[2]
        }
    end
    PARSER.CACHE_TREEPARAMS = treeParams

    --LOG("\n"..tostring(_TableToString(treeParams)))

    local treekey, treevalue = GetItemKey(treeParams, PARSER.KEYS_SearchingGradient)
    
    local TREE = {
        treeName = treeParams["_itemTag"] or PARSER.ROOT,
        treeObjName = treevalue or "",
        _customValue = treeParams["_customValue"],
        treeParams = PARSER.TREEPARAMS or PARSER.CACHE_TREEPARAMS,
        treeData = PARSER.TREEDATA or {},
        content = PARSER.CACHEDFILEDATA or PARSER.FILEDATA or {},
        firstLine = PARSER.TREEFIRSTLINE or 1,
        lastLine = PARSER.TREELASTLINE or 1
    }

    function TREE:tryUpdate()
        if PARSER.AUTOUPDATE then
            parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:tryUpdate ::::")
            parserLOG("[I] Module XMLParser.lua === AutoUpdateTree() is enabled")
            parserPRINT("AutoUpdateTree() is enabled")
            TREE:init()
            return true
        end
        return nil
    end

    function TREE:init(new_treeParams)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:init ::::")
        local treeData_, content_, firstLine_, lastLine_ = XMLParser:getTree(new_treeParams or treeParams)
        if treeData_ and content_ and firstLine_ and lastLine_ then
            local treekey, treevalue = GetItemKey(treeData_[1], PARSER.KEYS_SearchingGradient)
            --parserLOG("LITERAL\n".._TableToString(content_))
            PARSER.TREEPARAMS = treeParams
            PARSER.CACHE_TREEPARAMS = treeParams
            PARSER.TREEDATA = treeData_
            PARSER.FILEDATA = content_
            PARSER.TREEFIRSTLINE = firstLine_
            PARSER.TREELASTLINE = lastLine_
            TREE["treeName"] = treeData_[1]["_itemTag"] or PARSER.ROOT
            TREE["treeObjName"] = treevalue or ""
            TREE["treeParams"] = PARSER.TREEPARAMS
            TREE["treeData"] = PARSER.TREEDATA
            TREE["content"] = PARSER.FILEDATA
            TREE["firstLine"] = PARSER.TREEFIRSTLINE
            TREE["lastLine"] = PARSER.TREELASTLINE
            --parserLOG("UPDATE\n".._TableToString(TREE["content"]))
            parserLOG("[I] Module XMLParser.lua === Tree <"..TREE["treeName"].."> with name '"..TREE["treeObjName"].."' updated")
            parserPRINT("Tree <"..TREE["treeName"].."> with name '"..TREE["treeObjName"].."' updated")
            return true
        end
        return nil
    end


    function TREE:Add(objectParams, bEnters, bSpaces, includeKeysForSort)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:Add ::::")
        TREE:tryUpdate()
        if not type(objectParams)=="table" then
            LOG("[E] Module XMLParser.lua === Invalid objectParams data")
            error("XMLParser: Invalid objectParams data")
        end
        if not objectParams["_itemTag"] then
            LOG("[E] Module XMLParser.lua === Invalid _itemTag data")
            error("XMLParser: Invalid _itemTag data")
        end
        if ((objectParams["_itemClass"]~="tree") and (objectParams["_itemClass"]~="object")) then
            LOG("[E] Module XMLParser.lua === Invalid item class data")
            error("XMLParser: Invalid item class data")
        end

        if bEnters then
            PARSER.ENTERS = true
        else
            PARSER.ENTERS = false
        end
        if bSpaces then
            PARSER.SPACES = true
        else
            PARSER.SPACES = false
        end

        local KeyForSearch, KeyValueForSearch = GetItemKey(objectParams, PARSER.KEYS_SearchingGradient)

        local added = false
        local existing_object
        if objectParams["_itemClass"]=="tree" then
            local exists, existing_object = XMLParser:Tree():IsTreeExists({objectParams["_itemTag"], objectParams[KeyForSearch]}, KeyValueForSearch)
            if not exists then
                added = XMLParser:addTree(objectParams, TREE["treeData"][1], includeKeysForSort)
            end
        elseif objectParams["_itemClass"]=="object" then
            local exists, existing_object = XMLParser:Tree():IsObjectExists({objectParams["_itemTag"], objectParams[KeyForSearch]}, KeyValueForSearch)
            if not exists then
                added = XMLParser:addObject(objectParams, TREE["treeData"][1], includeKeysForSort)
            end
        end

        if added then 
            parserLOG("[I] Module XMLParser.lua === Added item with class '"..tostring(objectParams["_itemClass"]).."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" to '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
            parserPRINT("Added item with class '"..tostring(objectParams["_itemClass"]).."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" to '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
            return true 
        else
            parserLOG("[E] Module XMLParser.lua === Failed to add item with class '"..objectParams["_itemClass"].."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" to '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
            parserPRINT("Failed to add item with class '"..tostring(objectParams["_itemClass"]).."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" to '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
        end

        return nil, existing_object
    end

    function TREE:Remove(objectParams)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:Remove ::::")
        TREE:tryUpdate()
        local removed = false

        if type(objectParams)=="table" then
            if not objectParams["_itemTag"] then
                LOG("[E] Module XMLParser.lua === Invalid _itemTag data")
                error("XMLParser: Invalid _itemTag data")
            end
            if (not (objectParams["_itemClass"]=="tree") and not (objectParams["_itemClass"]=="object")) then
                LOG("[E] Module XMLParser.lua === Invalid item class data")
                error("XMLParser: Invalid item class data")
            end
        elseif objectParams=="self" then
            removed = XMLParser:removeTree(
                TREE["treeData"][1], 
                TREE["firstLine"]
            )
            if removed then 
                return true 
            else
                return nil
            end
        else
            LOG("[E] Module XMLParser.lua === Invalid objectParams data")
            error("XMLParser: Invalid objectParams data")
        end

        local KeyForSearch, KeyValueForSearch = GetItemKey(objectParams, PARSER.KEYS_SearchingGradient)

        if objectParams["_itemClass"]=="tree" then
            local _, idValue = GetItemKey(objectParams, PARSER.KEYS_Id)

            local tree
            local treeByName = TREE:GetTreeByName(objectParams["Name"] or "")
            local treeByTag = TREE:GetTree(objectParams["_itemTag"])
            local treeByCustomKey = TREE:GetTreeByCustomKey(KeyForSearch, KeyValueForSearch)
            local treeById = TREE:GetTreeById(idValue)

            treeById = treeById or {}
            treeByCustomKey = treeByCustomKey or {}
            treeByName = treeByName or {}
            treeByTag = treeByTag or {}

            if treeById["_itemLine"] then
                tree = treeById
            elseif treeByCustomKey["_itemLine"] then
                tree = treeByCustomKey
            elseif treeByName["_itemLine"]==treeByTag["_itemLine"] then
                tree = treeByName
            elseif treeByTag and not KeyValueForSearch then
                tree = treeByTag
            end

            if tree then
                local line = tree["_itemLine"]
                --println("line : "..line)
                removed = XMLParser:removeTree(objectParams, line)
            end
        else
            removed = XMLParser:removeObject(TREE["treeData"][1], objectParams)
        end

        if removed then 
            parserLOG("[I] Module XMLParser.lua === Removed item with class '"..tostring(objectParams["_itemClass"]).."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" in '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
            parserPRINT("Removed item with class '"..tostring(objectParams["_itemClass"]).."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" in '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
            return true 
        else
            parserLOG("[E] Module XMLParser.lua === Failed to remove item with class '"..objectParams["_itemClass"].."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" in '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
            parserPRINT("Failed to remove item with class '"..tostring(objectParams["_itemClass"]).."', tag <"..tostring(objectParams["_itemTag"]).."> and value \""..tostring(objectParams[KeyForSearch]).."\" in '"..tostring(TREE["treeData"][1]["_itemTag"]).."'")
        end

        return nil
    end



    function TREE:SetParam(paramKey, paramValue)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:SetParam ::::")
        TREE:tryUpdate()
        local paramKey = paramKey or "Name"
        local paramValue = paramValue or "NewValue"
        if paramKey=="_itemTag" then
            LOG("[E] Module XMLParser.lua === You cannot change the tag name using this command")
            error("XMLParser: You cannot change the tag name using this command")
        end

        if TREE["content"] then
            local line = TREE["firstLine"]
            while ((TREE["content"][line]~=nil) or (line==TREE["lastLine"])) do
                if string.find(TREE["content"][line], paramKey) then
                    local editedStr, count = string.gsub(TREE["content"][line], '(%s+)'..tostring(paramKey)..'(%s*)=(%s*)"[^"]*"', '%1'..tostring(paramKey)..'%2=%3"'..tostring(paramValue)..'"')
                    if count>0 then
                        TREE["content"][line] = editedStr

                        --WriteXMLParserFileForTable(TREE["content"])
                        CollectContentTable(TREE["content"])
                        return true
                    end
                end
                line=line+1
                if string.find(TREE["content"][line-1], ">") then
                    break
                end
            end
        end
        return nil
    end

    function TREE:GetParam(stringParameterName)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetParam ::::")
        TREE:tryUpdate()
        local Value
        if TREE["treeData"][1] then
            Value = TREE["treeData"][1][stringParameterName]
        end
        return _INTERPRETATION(Value)
    end

    function TREE:AddParam(paramKey, paramValue, bSpaces)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:AddParam ::::")
        TREE:tryUpdate()
        local paramKey = paramKey or "NewParam"
        local paramValue = paramValue or "NewValue"
        
        if IsKeyForbidden(paramKey) then
            LOG("[E] Module XMLParser.lua === You cannot add the '"..paramKey.."' using this command")
            error("XMLParser: You cannot add the '"..paramKey.."' using this command")
        end

        if TREE["treeData"] then
            if TREE["treeData"][1] then
                if TREE["treeData"][1][paramKey] then
                    parserLOG("[E] Module XMLParser.lua === This key '"..paramKey.."' already exists")
                    parserPRINT("This key '"..paramKey.."' already exists")
                    return false
                end
            end
        end

        if TREE["content"] then
            local paramLine = TREE["firstLine"]
            while ((TREE["content"][paramLine]~=nil) or (paramLine==TREE["lastLine"])) do
                if string.find(TREE["content"][paramLine], ">") then
                    break
                end
                paramLine=paramLine+1
            end

            local lineForAddParam = TREE["content"][paramLine]

            local savedTabs = ""
            local _, _, savedTabss = string.find(TREE["content"][paramLine], "(\t*)")
            if savedTabss then
                savedTabs = savedTabss
            end

            local strSpaces = ""
            if bSpaces then
                strSpaces = " "
            end

            local newStr = paramKey..''..strSpaces..'='..strSpaces..'"'..paramValue..'"'
            if string.find(TREE["content"][paramLine], "<"..TREE["treeName"]) then
                TREE["content"][paramLine], count = string.gsub(TREE["content"][paramLine], '(%s*[^>]*)>', '%1 '..newStr..'>')
                if count==0 then
                    return nil
                end
            else
                TREE["content"][paramLine] = string.gsub(TREE["content"][paramLine], ">", "")
                paramLine = paramLine + 1
                newStr = savedTabs..""..newStr..">"
                table.insert(TREE["content"], paramLine, newStr)
            end

            --WriteXMLParserFileForTable(TREE["content"])
            CollectContentTable(TREE["content"])
            return true
        end
        return nil
    end

    function TREE:RemoveParam(paramKey)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:RemoveParam ::::")
        TREE:tryUpdate()
        local paramKey = paramKey or "NewParam"
        
        if IsKeyForbidden(paramKey) then
            LOG("[E] Module XMLParser.lua === You cannot remove the '"..paramKey.."' using this command")
            error("XMLParser: You cannot remove the '"..paramKey.."' using this command")
        end

        if TREE["treeData"] then
            if TREE["treeData"][1] then
                local linez = 1
                if not TREE["treeData"][1][paramKey] then
                    parserLOG("[E] Module XMLParser.lua === Key '"..paramKey.."' does not exist")
                    parserPRINT("Key '"..paramKey.."' does not exist")
                    return false
                end
            end
        end

        if TREE["content"] then
            --local findObjectPattern = '%s*<([^!>%s%/]+)>?[/%s]?'
            local findParamPattern = '%s+'..paramKey..'%s*=+%s*"([^"]*)"'

            local paramLine = TREE["firstLine"]
            while ((TREE["content"][paramLine]~=nil) or (paramLine==TREE["lastLine"])) do
                if string.find(TREE["content"][paramLine], findParamPattern) then
                    break
                end
                paramLine=paramLine+1
            end

            local newStr = ""
            if string.find(TREE["content"][paramLine], "<"..TREE["treeName"]) then
                TREE["content"][paramLine], count = string.gsub(TREE["content"][paramLine], '%s*'..findParamPattern, newStr)
                if count==0 then
                    return nil
                end
            else
                if string.find(TREE["content"][paramLine], ">") then
                    table.remove(TREE["content"], paramLine)
                    paramLine=paramLine-1
                    TREE["content"][paramLine] = string.gsub(TREE["content"][paramLine], '(<?[^%s]*"?[^%s])', '%1>')
                else
                    table.remove(TREE["content"], paramLine)
                end
            end

            --WriteXMLParserFileForTable(TREE["content"])
            CollectContentTable(TREE["content"])
            return true
        end
        return nil
    end

    function TREE:AddAsTextField(fieldParams, stringTextFieldValue, boolEnters)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:AddAsTextField ::::")
        TREE:tryUpdate()
        local textField

        stringTextFieldValue = stringTextFieldValue or ""

        local fieldkey, stringCustomKeyValue = GetItemKey(fieldParams, PARSER.KEYS_SearchingGradient)
        local tableTextFieldTagXorCustomKey = {fieldParams._itemTag, fieldkey}

        local exists = XMLParser:Tree():IsTreeExists(tableTextFieldTagXorCustomKey, stringCustomKeyValue)
        if not exists or cachedItemLine then
            local stringTextFieldName = tableTextFieldTagXorCustomKey[1]
            local file = TREE["content"]
            local _itemLine = cachedItemLine or tonumber(TREE["firstLine"]) or 1
            if file and _itemLine then
                if file[_itemLine] then
                    local _,_, tabs = string.find(file[_itemLine], "(\t*)")
                    if not tabs then tabs = "" end

                    _itemLine = _itemLine + 1

                    textField = tabs..'\t<'..tostring(stringTextFieldName)
                    if tableTextFieldTagXorCustomKey[2] then
                        textField = textField..' '..tostring(fieldkey)..'="'..tostring(stringCustomKeyValue)..'"'
                    end
                    textField = textField..'>'
                    if string.find(stringTextFieldValue, '\n') then
                        local str = stringTextFieldValue
                        if string.sub(str, -1)~="\n" then
                            str = str.."\n"
                        end
                        local lines = {}
                        local start_pos = 1
                        while true do
                            local end_pos = string.find(str, "\n", start_pos)
                            if not end_pos then
                                break
                            end
                            local line = string.sub(str, start_pos, end_pos - 1)
                            line = ""..line
                            if lines[1] then
                                line = tabs.."\t\t"..line
                            end
                            table.insert(lines, line)
                            start_pos = end_pos + 1
                        end
                        for i, v in ipairs(lines) do
                            textField = textField..v..'\n'
                        end
                        if string.sub(stringTextFieldValue, -1)~="\n" then
                            textField = string.sub(textField, 1, -2)
                        else
                            textField = textField..tabs..'\t'
                        end
                    else
                        textField = textField..stringTextFieldValue
                    end
                    textField = textField..'</'..tostring(stringTextFieldName)..'>'

                    if boolEnters then
                        if not string.find(file[_itemLine], tabs..'</'..tostring(TREE["treeName"])) then
                            textField = textField..'\n'
                        end
                    end

                    table.insert(file, _itemLine, textField)
                end
            end
        end

        parserLOG("add {"..tostring(textField).."}")

        return textField, _itemLine
    end
    function TREE:ReadAsTextField(fieldParams, boolNoLines)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:ReadAsTextField ::::")
        TREE:tryUpdate()
        local treeBody = ""

        local fieldkey, stringCustomKeyValue = "field", fieldParams.field
        if not stringCustomKeyValue then
            fieldkey, stringCustomKeyValue = GetItemKey(fieldParams, PARSER.KEYS_SearchingGradient)
        end
        local tableTextFieldTagXorCustomKey = {fieldParams._itemTag, fieldkey}

        local exists, obj = XMLParser:Tree():IsTreeExists(tableTextFieldTagXorCustomKey, stringCustomKeyValue)
        if exists then
            local stringTextFieldName = tableTextFieldTagXorCustomKey[1]
            local file = TREE["content"]
            local _itemLine = obj._itemLine or tonumber(TREE["firstLine"]) or 1
            if file and _itemLine then
                if file[_itemLine] then
                    local _,_, tabs = string.find(file[_itemLine], "(\t*)")
                    if not tabs then tabs = "" end
                    local field = {}
                    while file[_itemLine] do
                        table.insert(field, file[_itemLine])
                        if string.find(file[_itemLine], "</"..tostring(stringTextFieldName)..">") or string.find(file[_itemLine], "</"..tostring(TREE["treeName"])..">") then
                            break
                        end
                        _itemLine=_itemLine+1
                        if not file[_itemLine] then
                            break
                        end
                    end
                    field = table.concat(field, '\n')
                    local _,_, fieldContent = string.find(field, "<"..tostring(stringTextFieldName).."[^>]*>([^<]*)</"..tostring(stringTextFieldName)..">")
                    if fieldContent then
                        treeBody = string.gsub(fieldContent, "\t", "")
                        if string.sub(treeBody, -1)=="\n" then
                            treeBody = string.sub(treeBody, 1, -2)
                        end
                    end
                end
            end
        end

        if boolNoLines then
            treeBody = string.gsub(treeBody, "\n", "")
        end

        parserLOG("return {"..treeBody.."}")

        return treeBody
    end
    function TREE:EditAsTextField(fieldParams, stringTextFieldNewValue)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:EditAsTextField ::::")
        TREE:tryUpdate()
        local textField

        local fieldkey, stringCustomKeyValue = "field", fieldParams.field
        if not stringCustomKeyValue then
            fieldkey, stringCustomKeyValue = GetItemKey(fieldParams, PARSER.KEYS_SearchingGradient)
        end
        local tableTextFieldTagXorCustomKey = {fieldParams._itemTag, fieldkey}

        stringTextFieldNewValue = stringTextFieldNewValue or ""

        local exists, obj = XMLParser:Tree():IsTreeExists(tableTextFieldTagXorCustomKey, stringCustomKeyValue)
        if exists then
            local stringTextFieldName = tableTextFieldTagXorCustomKey[1]
            local file = TREE["content"]
            local _itemLine = obj._itemLine or tonumber(TREE["firstLine"]) or 1
            if file and _itemLine then
                if file[_itemLine] then
                    local _,_, tabs = string.find(file[_itemLine], "(\t*)")
                    if not tabs then tabs = "" end

                    local _itemLine_ = _itemLine
                    local field = {}
                    while file[_itemLine] do
                        table.insert(field, file[_itemLine])
                        if string.find(file[_itemLine], "</"..tostring(stringTextFieldName)..">") or string.find(file[_itemLine], "</"..tostring(TREE["treeName"])..">") then
                            break
                        end
                        _itemLine=_itemLine+1
                        if not file[_itemLine] then
                            break
                        end
                    end
                    field = table.concat(field, '\n')
                    stringTextFieldNewValue = string.gsub(stringTextFieldNewValue, '\n', '\n'..tabs..'\t')
                    if string.sub(stringTextFieldNewValue, -1)=="\n" then
                        stringTextFieldNewValue = stringTextFieldNewValue.."\n"..tabs
                    end
                    local field2 = string.gsub(field, "(<"..tostring(stringTextFieldName).."[^>]*>)[^<]*(</"..tostring(stringTextFieldName)..">)", "%1"..stringTextFieldNewValue.."%2")

                    local content = table.concat(TREE["content"], '\n')
                    content = string.gsub(content, field, field2)

                    textField = stringTextFieldNewValue

                    content = PackTableFromString(content)

                    CollectContentTable(content)
                end
            end
        end

        return textField
    end

    function TREE:GetName()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetName ::::")
        TREE:tryUpdate()
        return TREE["treeName"]
    end
    function TREE:GetObjName()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetObjName ::::")
        TREE:tryUpdate()
        return TREE["treeObjName"]
    end
    function TREE:GetCustomValue()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetCustomValue ::::")
        TREE:tryUpdate()
        return TREE["_customValue"]
    end
    function TREE:GetParamsAmount()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetParamsAmount ::::")
        TREE:tryUpdate()
        local skoka = 0
        if TREE["treeData"][1] then
            for i, v in pairs(TREE["treeData"][1]) do
                skoka=skoka+1
            end
        end
        return skoka
    end

    function TREE:GetTreeById(intId)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetTreeById ::::")
        TREE:tryUpdate()
        local intId = intId or -1
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="tree") then
                    local _, idValue = GetItemKey(TREE["treeData"][2][i]["_itemProperties"], PARSER.KEYS_Id)
                    if idValue and intId then
                        if tonumber(idValue)==tonumber(intId) then
                            return TREE["treeData"][2][i]
                        end
                    end
                end
                i=i+1
            end
        end
        return nil
    end
    function TREE:GetTreeByCustomKey(stringCustomKey, stringCustomKeyValue)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetTreeByCustomKey ::::")
        TREE:tryUpdate()
        local stringCustomKey = stringCustomKey or ""
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="tree") then
                    local k = TREE["treeData"][2][i]["_itemProperties"][stringCustomKey]
                    local v = stringCustomKeyValue
                    if k then
                        if v then
                            if k==v then
                                return TREE["treeData"][2][i]
                            end
                        else
                            return TREE["treeData"][2][i]
                        end
                    end
                end
                i=i+1
            end
        end
        return nil
    end
    function TREE:GetTreeByName(stringTreeObjName)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetTreeByName ::::")
        TREE:tryUpdate()
        local stringTreeObjName = stringTreeObjName or ""
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="tree") then
                    local treekey, treevalue = GetItemKey(TREE["treeData"][2][i]["_itemProperties"], PARSER.KEYS_Name)
                    if treevalue==stringTreeObjName then
                        return TREE["treeData"][2][i]
                    end
                end
                i=i+1
            end
        end
        return nil
    end
    function TREE:GetTree(stringTreeName)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetTree ::::")
        TREE:tryUpdate()
        local stringTreeName = stringTreeName or ""
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="tree") then
                    if (TREE["treeData"][2][i]["_itemTag"]==stringTreeName) then
                        return TREE["treeData"][2][i]
                    end
                end
                i=i+1
            end
        end
        return nil
    end
    function TREE:GetItemsAmount()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetItemsAmount ::::")
        TREE:tryUpdate()
        local skoka, j = 0, 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][j]~=nil do
                skoka=skoka+1
                j=j+1
            end
        end
        return skoka
    end
    function TREE:GetChildsAmount()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetChildsAmount ::::")
        TREE:tryUpdate()
        local skoka = 0
        local skokas = 1
        if TREE["treeData"][3] then
            if TREE["treeData"][3][skokas] then
                while TREE["treeData"][3][skokas]~=nil do
                    if TREE["treeData"][3][skokas]["_itemChild"] then
                        skoka=skoka+1
                    end
                    skokas=skokas+1
                end
            end
        end
        return skoka
    end

    function TREE:GetObjectById(intId)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetObjectById ::::")
        TREE:tryUpdate()
        local intId = intId or -1
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="object") and (TREE["treeData"][2][i]["_itemProperties"]) then
                    local _, idValue = GetItemKey(TREE["treeData"][2][i]["_itemProperties"], PARSER.KEYS_Id)
                    if idValue and intId then
                        if tonumber(idValue)==tonumber(intId) then
                            return TREE["treeData"][2][i]
                        end
                    end
                end
                i=i+1
            end
        end
        return nil
    end
    function TREE:GetObjectByCustomKey(stringCustomKey, stringCustomKeyValue)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetObjectByName ::::")
        TREE:tryUpdate()
        local stringCustomKey = stringCustomKey or ""
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="object") and (TREE["treeData"][2][i]["_itemProperties"]) then
                    local keyval = TREE["treeData"][2][i]["_itemProperties"][stringCustomKey]
                    if keyval then
                        if stringCustomKeyValue then
                            if keyval==stringCustomKeyValue then
                                return TREE["treeData"][2][i]
                            end
                        else
                            return TREE["treeData"][2][i]
                        end
                    end
                end
                i=i+1
            end
        end
        return nil
    end
    function TREE:GetObjectByName(stringItemObjName)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetObjectByName ::::")
        TREE:tryUpdate()
        local stringItemObjName = stringItemObjName or ""
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="object") and (TREE["treeData"][2][i]["_itemProperties"]) then
                    local objkey, objvalue = GetItemKey(TREE["treeData"][2][i]["_itemProperties"], PARSER.KEYS_Name)
                    if objvalue==stringItemObjName then
                        return TREE["treeData"][2][i]
                    end
                end
                i=i+1
            end
        end
        return nil
    end
    function TREE:GetObject(stringItemName)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetObject ::::")
        TREE:tryUpdate()
        local stringItemName = stringItemName or ""
        local i = 1
        if TREE["treeData"][2] then
            while TREE["treeData"][2][i]~=nil do
                if (TREE["treeData"][2][i]["_itemClass"]=="object") then
                    if TREE["treeData"][2][i]["_itemTag"]==stringItemName then
                        return TREE["treeData"][2][i]
                    end
                end
                i=i+1
            end
        end
        return nil
    end

    function TREE:GetParams()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetParams ::::")
        TREE:tryUpdate()
        return TREE["treeData"][1]
    end
    function TREE:GetItems()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetItems ::::")
        TREE:tryUpdate()
        return TREE["treeData"][2]
    end
    function TREE:GetChilds()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetChilds ::::")
        TREE:tryUpdate()
        local childs_exists = function()
                for i, _ in ipairs(TREE["treeData"][3]) do
                    if TREE["treeData"][3][i] then
                        if TREE["treeData"][3][i]["_itemChilds"] then
                            return true
                        end
                    end
                end
                return false
            end
        if not childs_exists() then
            return nil
        end
        return TREE["treeData"][3]
    end
    -- function TREE:GetParentName()
    --     parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:GetParent ::::")
    --     TREE:tryUpdate()
    --     return TREE["treeData"][1]["_itemParent"]
    -- end


    

    function TREE:IsObjectExists(tableObjectTagXorCustomKey, stringCustomKeyValue)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:IsObjectExists ::::")
        TREE:tryUpdate()
        local ObjectExists = false
        local obj = TREE:GetObj(tableObjectTagXorCustomKey, stringCustomKeyValue)
        if obj then
            ObjectExists = true
        end
        return ObjectExists, obj
    end

    function TREE:IsTreeExists(tableTreeTagXorCustomKey, stringCustomKeyValue)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:IsTreeExists ::::")
        TREE:tryUpdate()
        local TreeExists = false
        local tree

        local stringCustomKey = tableTreeTagXorCustomKey[2]
        local treeById = TREE:GetTreeById(stringCustomKey)
        local treeByCustomKey = TREE:GetTreeByCustomKey(stringCustomKey, stringCustomKeyValue)
        local treeByName = TREE:GetTreeByName(stringCustomKey)
        local stringTreeTag = tableTreeTagXorCustomKey[1]
        local treeByTag = TREE:GetTree(stringTreeTag)
        
        -- println("stringCustomKeyValue {"..tostring(stringCustomKeyValue).."}")
        -- println("stringCustomKey {"..tostring(stringCustomKey).."}")
        -- println("stringTreeTag {"..tostring(stringTreeTag).."}")

        --println(treeByCustomKey)

        if treeById then
            tree = treeById
            --println("id")
        elseif treeByCustomKey then
            tree = treeByCustomKey
            --println("CustomKey")
        elseif treeByName then
            tree = treeByName
            --println("Name")
        elseif treeByTag and not stringCustomKey then
            tree = treeByTag
            --println("Tag")
        end
        if tableTreeTagXorCustomKey[1] and tableTreeTagXorCustomKey[2] then
            if treeByCustomKey and treeByTag then
                if treeByCustomKey["_itemLine"]==treeByTag["_itemLine"] then
                    tree = treeByCustomKey or treeByTag
                end
            end
        end

        if tree then
            TreeExists = true
        end
        return TreeExists, tree
    end



    function TREE:CleanEnters()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:CleanEnters ::::")
        TREE:tryUpdate()

        if TREE["firstLine"] and TREE["content"] and TREE["treeName"] then
            local firstLine = TREE["firstLine"]
            local content = TREE["content"]
            local tag = TREE["treeName"]
            
            local savedTabs = ""
            local _, _, savedTabss = string.find(content[firstLine], "(\t*)")
            if savedTabss then
                savedTabs = savedTabss
            end

            while content[firstLine]~=savedTabs.."</"..tag..">" do
                firstLine=firstLine+1
                if not content[firstLine] then
                    break
                end
                if (content[firstLine]=="\t*") or (content[firstLine]=="%s*") or (content[firstLine]=="") then
                    table.remove(content, firstLine)
                end
            end

            --WriteXMLParserFileForTable(content)
            CollectContentTable(content)
            return true
        end
        
        return nil
    end
    function TREE:AddEnters()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:AddEnters ::::")
        TREE:tryUpdate()

        if TREE["firstLine"] and TREE["content"] and TREE["treeName"] then
            local firstLine = TREE["firstLine"]
            local content = TREE["content"]
            local tag = TREE["treeName"]
            
            local savedTabs = ""
            local _, _, savedTabss = string.find(content[firstLine], "(\t*)")
            if savedTabss then
                savedTabs = savedTabss
            end

            while content[firstLine]~=savedTabs.."</"..tag..">" do
                firstLine=firstLine+1
                if not content[firstLine] or content[firstLine]==savedTabs.."</"..tag..">" then
                    break
                end
                if (string.find(content[firstLine], "/>") or string.find(content[firstLine], "</")) and not ((content[firstLine+1]=="\t*") or (content[firstLine+1]=="%s*") or (content[firstLine+1]=="")) and content[firstLine+1]~=savedTabs.."</"..tag..">" then
                    table.insert(content, firstLine+1, "")
                end
            end

            --WriteXMLParserFileForTable(content)
            CollectContentTable(content)
            return true
        end
        
        return nil
    end



    function TREE:CaptureInnerTree(tableTreeTagXorCustomKey, stringCustomKeyValue)
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:CaptureInnerTree ::::")
        TREE:tryUpdate()

        local exists, tree = TREE:IsTreeExists(tableTreeTagXorCustomKey, stringCustomKeyValue)

        if exists and tree then
            tree["_itemProperties"]._itemClass = "tree"
            tree["_itemProperties"]._itemTag = tree["_itemTag"]
            tree["_itemProperties"]._itemLine = tree["_itemLine"]
            treeParams = CopyItemParams(tree["_itemProperties"])

            local treeData_, content_, firstLine_, lastLine_ = XMLParser:getTree(treeParams)
            if treeData_ and content_ and firstLine_ and lastLine_ then
                local treekey, treevalue = GetItemKey(treeData_[1], PARSER.KEYS_SearchingGradient)
                PARSER.TREEPARAMS = treeParams
                PARSER.CACHE_TREEPARAMS = treeParams
                PARSER.TREEDATA = treeData_
                PARSER.FILEDATA = content_
                PARSER.TREEFIRSTLINE = firstLine_
                PARSER.TREELASTLINE = lastLine_
                TREE["treeName"] = treeData_[1]["_itemTag"] or PARSER.ROOT
                TREE["treeObjName"] = treevalue or ""
                TREE["treeParams"] = PARSER.TREEPARAMS
                TREE["treeData"] = PARSER.TREEDATA
                TREE["content"] = PARSER.FILEDATA
                TREE["firstLine"] = PARSER.TREEFIRSTLINE
                TREE["lastLine"] = PARSER.TREELASTLINE
                --parserLOG("UPDATE\n".._TableToString(TREE["content"]))
                parserLOG("[I] Module XMLParser.lua === Tree <"..TREE["treeName"].."> with name '"..TREE["treeObjName"].."' updated")
                parserPRINT("Tree <"..TREE["treeName"].."> with name '"..TREE["treeObjName"].."' updated")
                return true
            end
        end

        return nil
    end



    local function applyPostWrap(forWho, wrapedContent)
        parserLOG(":::: global method XMLParser:Tree :::: local native function applyPostWrap ::::")
        local wrapedContent = wrapedContent or ""
        if TREE["firstLine"] and TREE["content"] then
            local firstLine
            if forWho=="tree" then
                firstLine = TREE["firstLine"]
            else
                firstLine = forWho
            end
            local content = _CopyTable(TREE["content"])

            parserLOG("BefWrap::\n".._TableToString(content))

            while content[firstLine]=="" do
                firstLine=firstLine+1
            end

            while (content[firstLine]~=nil) and (string.find(content[firstLine], ">")==nil) do
                parserLOG("removed line::"..tostring(content[firstLine]))
                table.remove(content, firstLine)
            end
            parserLOG("removed line::"..tostring(content[firstLine]))
            table.remove(content, firstLine)

            if type(wrapedContent)=="table" then
                firstLine=firstLine-1
                for i, v in ipairs(wrapedContent) do
                    parserLOG("add line::"..v)
                    table.insert(content, firstLine+i, v)
                end
            else
                parserLOG("add line::"..wrapedContent)
                table.insert(content, firstLine, wrapedContent)
            end

            parserLOG("PostWrap::\n".._TableToString(content))

            local new_content = content
            TREE["content"] = new_content

            content = nil
            new_content = nil
            return true
        end
        return nil
    end

    function TREE:Wrap()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:Wrap ::::")
        TREE:tryUpdate()
        local wrapedTreeStr = XMLParser:Wrap("self")
        if wrapedTreeStr then
            local new_content = applyPostWrap("tree", wrapedTreeStr)
            if new_content then
                --WriteXMLParserFileForTable(TREE["content"])
                CollectContentTable(TREE["content"])
                return true
            end
        end
        return nil
    end
    function TREE:Unwrap()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:Unwrap ::::")
        TREE:tryUpdate()
        local unwrapedTree = XMLParser:Unwrap("self")
        if unwrapedTree then
            local newcontent = applyPostWrap("tree", unwrapedTree)
            if newcontent then
                --WriteXMLParserFileForTable(TREE["content"])
                CollectContentTable(TREE["content"])
                return true
            end
        end
        return nil
    end

    function TREE:WrapAllItems()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:WrapAllItems ::::")
        TREE:tryUpdate()
        if TREE["treeData"][2] then
            local item = 1
            while TREE["treeData"][2][item]~=nil do
                if not TREE:tryUpdate() then
                    LOG("[E] Module XMLParser.lua === Please, enable AutoUpdateTree() for work this function")
                    parserPRINT("Please, enable AutoUpdateTree() for work this function")
                    return nil
                end
                local objectParams = TREE["treeData"][2][item]
                local wrapedObjStr = XMLParser:Wrap(objectParams)
                if wrapedObjStr then
                    local newcontent = applyPostWrap(objectParams["_itemLine"], wrapedObjStr)
                    if newcontent then
                        --WriteXMLParserFileForTable(TREE["content"])
                        CollectContentTable(TREE["content"])
                    end
                end
                item = item + 1
            end
        end
        return nil
    end
    function TREE:UnwrapAllItems()
        parserLOG(":::: global method XMLParser:Tree :::: global native function TREE:UnwrapAllItems ::::")
        TREE:tryUpdate()
        if TREE["treeData"][2] then
            local item = 1
            while TREE["treeData"][2][item]~=nil do
                if not TREE:tryUpdate() then
                    LOG("[E] Module XMLParser.lua === Please, enable AutoUpdateTree() for work this function")
                    parserPRINT("Please, enable AutoUpdateTree() for work this function")
                    return nil
                end
                local objectParams = TREE["treeData"][2][item]
                local wrapedObjStr = XMLParser:Unwrap(objectParams)
                if wrapedObjStr then
                    local newcontent = applyPostWrap(objectParams["_itemLine"], wrapedObjStr)
                    if newcontent then
                        --WriteXMLParserFileForTable(TREE["content"])
                        CollectContentTable(TREE["content"])
                    end
                end
                item = item + 1
            end
        end
        return nil
    end




    --class object
    function TREE:GetObj(tableObjectTagXorCustomKey, stringCustomKeyValue)
        parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj ::::")
        TREE:tryUpdate()
        local object
        local stringCustomKey = tableObjectTagXorCustomKey[2]
        local objectById = TREE:GetObjectById(stringCustomKey)
        local objectByCustomKey = TREE:GetObjectByCustomKey(stringCustomKey, stringCustomKeyValue)
        local objectByName = TREE:GetObjectByName(stringCustomKey)
        local stringObjectTag = tableObjectTagXorCustomKey[1]
        local objectByTag = TREE:GetObject(stringObjectTag)
        
        if objectById then
            object = objectById
            --println("id")
        elseif objectByCustomKey then
            object = objectByCustomKey
            --println("CustomKey")
        elseif objectByName then
            object = objectByName
            --println("Name")
        elseif objectByTag and not stringCustomKey then
            object = objectByTag
            --println("Tag")
        end
        if tableObjectTagXorCustomKey[1] and tableObjectTagXorCustomKey[2] then
            if objectByCustomKey and objectByTag then
                if objectByCustomKey["_itemLine"]==objectByTag["_itemLine"] then
                    object = objectByCustomKey or objectByTag
                end
            end
        end

        if not object then
            parserLOG("[E] Module XMLParser.lua === Obj '"..stringObjectTag.."' does not exist")
            parserPRINT("Obj '"..stringObjectTag.."' does not exist")
            return nil
        end

        --parserLOG(tostring(_TableToString(object)))

        OBJ = {
            _object = object
        }

        function OBJ:GetProperties()
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:GetProperties ::::")
            return OBJ["_object"]["_itemProperties"]
        end
        function OBJ:GetProperty(paramName)
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:GetProperty ::::")
            local Value = OBJ["_object"]["_itemProperties"][paramName]
            return _INTERPRETATION(Value)
        end

        function OBJ:SetProperty(paramKey, paramValue)
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:SetProperty ::::")
            local paramKey = paramKey or "Name"
            local paramValue = paramValue or "NewValue"
            if paramKey=="_itemTag" then
                LOG("[E] Module XMLParser.lua === You cannot change the tag name using this command")
                error("XMLParser: You cannot change the tag name using this command")
            end
    
            if TREE["content"] then
                local line = OBJ["_object"]["_itemLine"]
                while ((TREE["content"][line]~=nil) or (line==TREE["lastLine"])) do
                    if string.find(TREE["content"][line], paramKey) then
                        local editedStr, count = string.gsub(TREE["content"][line], '(%s+)'..tostring(paramKey)..'(%s*)=(%s*)"[^"]*"', '%1'..tostring(paramKey)..'%2=%3"'..tostring(paramValue)..'"')
                        if count>0 then
                            TREE["content"][line] = editedStr
    
                            --WriteXMLParserFileForTable(TREE["content"])
                            CollectContentTable(TREE["content"])
                            return true
                        end
                    end
                    line=line+1
                    if string.find(TREE["content"][line-1], ">") then
                        break
                    end
                end
            end
            return nil
        end

        function OBJ:AddProperty(paramKey, paramValue, bSpaces)
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:AddProperty ::::")
            local paramKey = paramKey or "NewParam"
            local paramValue = paramValue or "NewValue"
            
            if IsKeyForbidden(paramKey) then
                LOG("[E] Module XMLParser.lua === You cannot add the '"..paramKey.."' using this command")
                error("XMLParser: You cannot add the '"..paramKey.."' using this command")
            end
    
            if OBJ["_object"]["_itemProperties"] then
                if OBJ["_object"]["_itemProperties"][paramKey] then
                    parserLOG("[E] Module XMLParser.lua === This key '"..paramKey.."' already exists")
                    parserPRINT("This key '"..paramKey.."' already exists")
                    return false
                end
            end
    
            if TREE["content"] then
                local paramLine = OBJ["_object"]["_itemLine"]
                while ((TREE["content"][paramLine]~=nil) or (paramLine==TREE["lastLine"])) do
                    if string.find(TREE["content"][paramLine], "/>") then
                        break
                    end
                    paramLine=paramLine+1
                end
    
                local lineForAddParam = TREE["content"][paramLine]
    
                local savedTabs = ""
                local _, _, savedTabss = string.find(TREE["content"][paramLine], "(\t*)")
                if savedTabss then
                    savedTabs = savedTabss
                end

                local strSpaces = ""
                if bSpaces then
                    strSpaces = " "
                end
    
                local newStr = paramKey..''..strSpaces..'='..strSpaces..'"'..paramValue..'"'
                if string.find(TREE["content"][paramLine], "<"..OBJ["_object"]["_itemTag"]) then
                    TREE["content"][paramLine], count = string.gsub(TREE["content"][paramLine], '(%s*[^/]*)/>', '%1 '..newStr..' />')
                    if count==0 then
                        return nil
                    end
                else
                    TREE["content"][paramLine] = string.gsub(TREE["content"][paramLine], "/>", "")
                    paramLine = paramLine + 1
                    newStr = savedTabs..""..newStr.." />"
                    table.insert(TREE["content"], paramLine, newStr)
                end
    
                --WriteXMLParserFileForTable(TREE["content"])
                CollectContentTable(TREE["content"])
                return true
            end
            return nil
        end
    
        function OBJ:RemoveProperty(paramKey)
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:RemoveProperty ::::")
            local paramKey = paramKey or "NewParam"
            
            if IsKeyForbidden(paramKey) then
                LOG("[E] Module XMLParser.lua === You cannot remove the '"..paramKey.."' using this command")
                error("XMLParser: You cannot remove the '"..paramKey.."' using this command")
            end
    
            if OBJ["_object"]["_itemProperties"] then
                if not OBJ["_object"]["_itemProperties"][paramKey] then
                    parserLOG("[E] Module XMLParser.lua === Key '"..paramKey.."' does not exist")
                    parserPRINT("Key '"..paramKey.."' does not exist")
                    return false
                end
            end
    
            if TREE["content"] then
                --local findObjectPattern = '%s*<([^!>%s%/]+)>?[/%s]?'
                local findParamPattern = '%s+'..paramKey..'%s*=+%s*"([^"]*)"'
    
                local paramLine = OBJ["_object"]["_itemLine"]
                while ((TREE["content"][paramLine]~=nil) or (paramLine==TREE["lastLine"])) do
                    if string.find(TREE["content"][paramLine], findParamPattern) then
                        break
                    end
                    paramLine=paramLine+1
                end
    
                local newStr = ""
                if string.find(TREE["content"][paramLine], "<"..OBJ["_object"]["_itemTag"]) then
                    TREE["content"][paramLine], count = string.gsub(TREE["content"][paramLine], '%s*'..findParamPattern, newStr)
                    if count==0 then
                        return nil
                    end
                else
                    if string.find(TREE["content"][paramLine], "/>") then
                        table.remove(TREE["content"], paramLine)
                        paramLine=paramLine-1
                        TREE["content"][paramLine] = string.gsub(TREE["content"][paramLine], '(<?[^%s]*"?[^%s])', '%1 />')
                    else
                        table.remove(TREE["content"], paramLine)
                    end
                end
    
                --WriteXMLParserFileForTable(TREE["content"])
                CollectContentTable(TREE["content"])
                return true
            end
            return nil
        end

        function OBJ:GetName()
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:GetName ::::")
            return OBJ["_object"]["_itemTag"]
        end
        function OBJ:GetObjName()
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:GetObjName ::::")
            local objkey, objvalue = GetItemKey(OBJ["_object"]["_itemProperties"], PARSER.KEYS_Name)
            return objvalue
        end

        function OBJ:GetPropertiesAmount()
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:GetPropertiesAmount ::::")
            local skoka = 0
            if OBJ["_object"]["_itemProperties"] then
                for i, v in pairs(OBJ["_object"]["_itemProperties"]) do
                    skoka=skoka+1
                end
            end
            return skoka
        end
        

        function OBJ:Wrap()
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:Wrap ::::")
            local objectParams = OBJ["_object"]
            local wrapedObjStr = XMLParser:Wrap(objectParams)
            if wrapedObjStr then
                local newcontent = applyPostWrap(objectParams["_itemLine"], wrapedObjStr)
                if newcontent then
                    --WriteXMLParserFileForTable(TREE["content"])
                    CollectContentTable(TREE["content"])
                    return true
                end
            end
            return nil
        end
        function OBJ:Unwrap()
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:Unwrap ::::")
            local objectParams = OBJ["_object"]
            local unwrapedObj = XMLParser:Unwrap(objectParams)
            if unwrapedObj then
                local newcontent = applyPostWrap(objectParams["_itemLine"], unwrapedObj)
                if newcontent then
                    --WriteXMLParserFileForTable(TREE["content"])
                    CollectContentTable(TREE["content"])
                    return true
                end
            end
            return nil
        end

        function OBJ:GetParentName()
            parserLOG(":::: global method XMLParser:Tree :::: global method TREE:GetObj :::: global native function OBJ:GetParentName ::::")
            return OBJ["_object"]["_itemParent"]
        end

        
        return OBJ
    end


    return TREE
end


-- /////////////////////////// RETURN MODULE ////////////////////////////////

LOG("[I] Module XMLParser.lua "..XMLParser.version.." successfully loaded.")

return XMLParser